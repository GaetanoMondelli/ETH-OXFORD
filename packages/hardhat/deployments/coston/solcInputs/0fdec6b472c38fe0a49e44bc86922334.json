{
  "language": "Solidity",
  "sources": {
    "@flarenetwork/flare-periphery-contracts/coston/ftso/ftso/interface/IIFtso.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\nimport \"../../genesis/interface/IFtsoGenesis.sol\";\nimport \"../../userInterfaces/IFtso.sol\";\nimport \"../../../util-contracts/token/token/interface/IIVPToken.sol\";\n\n\ninterface IIFtso is IFtso, IFtsoGenesis {\n\n    /// function finalizePriceReveal\n    /// called by reward manager only on correct timing.\n    /// if price reveal period for epoch x ended. finalize.\n    /// iterate list of price submissions\n    /// find weighted median\n    /// find adjucant 50% of price submissions.\n    /// Allocate reward for any price submission which is same as a \"winning\" submission\n    function finalizePriceEpoch(uint256 _epochId, bool _returnRewardData) external\n        returns(\n            address[] memory _eligibleAddresses,\n            uint256[] memory _natWeights,\n            uint256 _totalNatWeight\n        );\n\n    function fallbackFinalizePriceEpoch(uint256 _epochId) external;\n\n    function forceFinalizePriceEpoch(uint256 _epochId) external;\n\n    // activateFtso will be called by ftso manager once ftso is added \n    // before this is done, FTSO can't run\n    function activateFtso(\n        uint256 _firstEpochStartTs,\n        uint256 _submitPeriodSeconds,\n        uint256 _revealPeriodSeconds\n    ) external;\n\n    function deactivateFtso() external;\n\n    // update initial price and timestamp - only if not active\n    function updateInitialPrice(uint256 _initialPriceUSD, uint256 _initialPriceTimestamp) external;\n\n    function configureEpochs(\n        uint256 _maxVotePowerNatThresholdFraction,\n        uint256 _maxVotePowerAssetThresholdFraction,\n        uint256 _lowAssetUSDThreshold,\n        uint256 _highAssetUSDThreshold,\n        uint256 _highAssetTurnoutThresholdBIPS,\n        uint256 _lowNatTurnoutThresholdBIPS,\n        uint256 _elasticBandRewardBIPS,\n        uint256 _elasticBandWidthPPM,\n        address[] memory _trustedAddresses\n    ) external;\n\n    function setAsset(IIVPToken _asset) external;\n\n    function setAssetFtsos(IIFtso[] memory _assetFtsos) external;\n\n    // current vote power block will update per reward epoch. \n    // the FTSO doesn't have notion of reward epochs.\n    // reward manager only can set this data. \n    function setVotePowerBlock(uint256 _blockNumber) external;\n\n    function initializeCurrentEpochStateForReveal(uint256 _circulatingSupplyNat, bool _fallbackMode) external;\n  \n    /**\n     * @notice Returns ftso manager address\n     */\n    function ftsoManager() external view returns (address);\n\n    /**\n     * @notice Returns the FTSO asset\n     * @dev Asset is null in case of multi-asset FTSO\n     */\n    function getAsset() external view returns (IIVPToken);\n\n    /**\n     * @notice Returns the Asset FTSOs\n     * @dev AssetFtsos is not null only in case of multi-asset FTSO\n     */\n    function getAssetFtsos() external view returns (IIFtso[] memory);\n\n    /**\n     * @notice Returns current configuration of epoch state\n     * @return _maxVotePowerNatThresholdFraction        High threshold for native token vote power per voter\n     * @return _maxVotePowerAssetThresholdFraction      High threshold for asset vote power per voter\n     * @return _lowAssetUSDThreshold            Threshold for low asset vote power\n     * @return _highAssetUSDThreshold           Threshold for high asset vote power\n     * @return _highAssetTurnoutThresholdBIPS   Threshold for high asset turnout\n     * @return _lowNatTurnoutThresholdBIPS      Threshold for low nat turnout\n     * @return _elasticBandRewardBIPS           Hybrid reward band, where _elasticBandRewardBIPS goes to the \n        elastic band (prices within _elasticBandWidthPPM of the median) \n        and 10000 - elasticBandRewardBIPS to the IQR \n     * @return _elasticBandWidthPPM             Prices within _elasticBandWidthPPM of median are rewarded\n     * @return _trustedAddresses                Trusted addresses - use their prices if low nat turnout is not achieved\n     */\n    function epochsConfiguration() external view \n        returns (\n            uint256 _maxVotePowerNatThresholdFraction,\n            uint256 _maxVotePowerAssetThresholdFraction,\n            uint256 _lowAssetUSDThreshold,\n            uint256 _highAssetUSDThreshold,\n            uint256 _highAssetTurnoutThresholdBIPS,\n            uint256 _lowNatTurnoutThresholdBIPS,\n            uint256 _elasticBandRewardBIPS,\n            uint256 _elasticBandWidthPPM,\n            address[] memory _trustedAddresses\n        );\n\n    /**\n     * @notice Returns parameters necessary for approximately replicating vote weighting.\n     * @return _assets                  the list of Assets that are accounted in vote\n     * @return _assetMultipliers        weight of each asset in (multiasset) ftso, mutiplied by TERA\n     * @return _totalVotePowerNat       total native token vote power at block\n     * @return _totalVotePowerAsset     total combined asset vote power at block\n     * @return _assetWeightRatio        ratio of combined asset vp vs. native token vp (in BIPS)\n     * @return _votePowerBlock          vote powewr block for given epoch\n     */\n    function getVoteWeightingParameters() external view \n        returns (\n            IIVPToken[] memory _assets,\n            uint256[] memory _assetMultipliers,\n            uint256 _totalVotePowerNat,\n            uint256 _totalVotePowerAsset,\n            uint256 _assetWeightRatio,\n            uint256 _votePowerBlock\n        );\n\n    function wNat() external view returns (IIVPToken);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston/ftso/genesis/interface/IFtsoGenesis.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\n\ninterface IFtsoGenesis {\n    \n    /**\n     * @notice Submits price hash for current epoch - only price submitter\n     * @param _sender               Sender address\n     * @param _epochId              Target epoch id to which hashes are submitted\n     * @param _hash                 Hashed price and random number\n     * @notice Emits PriceHashSubmitted event. \n     */\n    function submitPriceHashSubmitter(address _sender, uint256 _epochId, bytes32 _hash) external;\n\n    /**\n     * @notice Reveals submitted price during epoch reveal period - only price submitter\n     * @param _voter                Voter address\n     * @param _epochId              Id of the epoch in which the price hash was submitted\n     * @param _price                Submitted price in USD\n     * @param _random               Submitted random number\n     * @notice The hash of _price and _random must be equal to the submitted hash\n     * @notice Emits PriceRevealed event\n     */\n    function revealPriceSubmitter(\n        address _voter,\n        uint256 _epochId,\n        uint256 _price,\n        uint256 _random,\n        uint256 _wNatVP\n    ) external;\n\n    /**\n     * @notice Get (and cache) wNat vote power for specified voter and given epoch id\n     * @param _voter                Voter address\n     * @param _epochId              Id of the epoch in which the price hash was submitted\n     * @return wNat vote power\n     */\n    function wNatVotePowerCached(address _voter, uint256 _epochId) external returns (uint256);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston/ftso/genesis/interface/IFtsoManagerGenesis.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\n\ninterface IFtsoManagerGenesis {\n\n    function getCurrentPriceEpochId() external view returns (uint256 _priceEpochId);\n\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston/ftso/genesis/interface/IFtsoRegistryGenesis.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\nimport \"./IFtsoGenesis.sol\";\n\n\ninterface IFtsoRegistryGenesis {\n\n    function getFtsos(uint256[] memory _indices) external view returns(IFtsoGenesis[] memory _ftsos);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston/ftso/userInterfaces/IFtso.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\ninterface IFtso {\n    enum PriceFinalizationType {\n        // initial state\n        NOT_FINALIZED,\n        // median calculation used to find price\n        WEIGHTED_MEDIAN,\n        // low turnout - price calculated from median of trusted addresses\n        TRUSTED_ADDRESSES,\n        // low turnout + no votes from trusted addresses - price copied from previous epoch\n        PREVIOUS_PRICE_COPIED,\n        // price calculated from median of trusted addresses - triggered due to an exception\n        TRUSTED_ADDRESSES_EXCEPTION,\n        // previous price copied - triggered due to an exception\n        PREVIOUS_PRICE_COPIED_EXCEPTION\n    }\n\n    // events\n    event PriceHashSubmitted(\n        address indexed submitter, uint256 indexed epochId, bytes32 hash, uint256 timestamp\n    );\n\n    event PriceRevealed(\n        address indexed voter, uint256 indexed epochId, uint256 price, uint256 random, uint256 timestamp,\n        uint256 votePowerNat, uint256 votePowerAsset\n    );\n\n    event PriceFinalized(\n        uint256 indexed epochId, uint256 price, bool rewardedFtso,\n        uint256 lowIQRRewardPrice, uint256 highIQRRewardPrice,\n        uint256 lowElasticBandRewardPrice, uint256 highElasticBandRewardPrice, \n        PriceFinalizationType finalizationType, uint256 timestamp\n    );\n\n    event PriceEpochInitializedOnFtso(\n        uint256 indexed epochId, uint256 endTime, uint256 timestamp\n    );\n\n    event LowTurnout(\n        uint256 indexed epochId,\n        uint256 natTurnout,\n        uint256 lowNatTurnoutThresholdBIPS,\n        uint256 timestamp\n    );\n\n    /**\n     * @notice Returns if FTSO is active\n     */\n    function active() external view returns (bool);\n\n    /**\n     * @notice Returns the FTSO symbol\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice Returns current epoch id\n     */\n    function getCurrentEpochId() external view returns (uint256);\n\n    /**\n     * @notice Returns id of the epoch which was opened for price submission at the specified timestamp\n     * @param _timestamp            Timestamp as seconds from unix epoch\n     */\n    function getEpochId(uint256 _timestamp) external view returns (uint256);\n    \n    /**\n     * @notice Returns random number of the specified epoch\n     * @param _epochId              Id of the epoch\n     */\n    function getRandom(uint256 _epochId) external view returns (uint256);\n\n    /**\n     * @notice Returns asset price consented in specific epoch\n     * @param _epochId              Id of the epoch\n     * @return Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\n     */\n    function getEpochPrice(uint256 _epochId) external view returns (uint256);\n\n    /**\n     * @notice Returns current epoch data\n     * @return _epochId                 Current epoch id\n     * @return _epochSubmitEndTime      End time of the current epoch price submission as seconds from unix epoch\n     * @return _epochRevealEndTime      End time of the current epoch price reveal as seconds from unix epoch\n     * @return _votePowerBlock          Vote power block for the current epoch\n     * @return _fallbackMode            Current epoch in fallback mode - only votes from trusted addresses will be used\n     * @dev half-closed intervals - end time not included\n     */\n    function getPriceEpochData() external view returns (\n        uint256 _epochId,\n        uint256 _epochSubmitEndTime,\n        uint256 _epochRevealEndTime,\n        uint256 _votePowerBlock,\n        bool _fallbackMode\n    );\n\n    /**\n     * @notice Returns current epoch data\n     * @return _firstEpochStartTs           First epoch start timestamp\n     * @return _submitPeriodSeconds         Submit period in seconds\n     * @return _revealPeriodSeconds         Reveal period in seconds\n     */\n    function getPriceEpochConfiguration() external view returns (\n        uint256 _firstEpochStartTs,\n        uint256 _submitPeriodSeconds,\n        uint256 _revealPeriodSeconds\n    );\n    \n    /**\n     * @notice Returns asset price submitted by voter in specific epoch\n     * @param _epochId              Id of the epoch\n     * @param _voter                Address of the voter\n     * @return Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\n     */\n    function getEpochPriceForVoter(uint256 _epochId, address _voter) external view returns (uint256);\n\n    /**\n     * @notice Returns current asset price\n     * @return _price               Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\n     * @return _timestamp           Time when price was updated for the last time\n     */\n    function getCurrentPrice() external view returns (uint256 _price, uint256 _timestamp);\n\n    /**\n     * @notice Returns current asset price and number of decimals\n     * @return _price                   Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\n     * @return _timestamp               Time when price was updated for the last time\n     * @return _assetPriceUsdDecimals   Number of decimals used for USD price\n     */\n    function getCurrentPriceWithDecimals() external view returns (\n        uint256 _price,\n        uint256 _timestamp,\n        uint256 _assetPriceUsdDecimals\n    );\n    \n    /**\n     * @notice Returns current asset price calculated from trusted providers\n     * @return _price               Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\n     * @return _timestamp           Time when price was updated for the last time\n     */\n    function getCurrentPriceFromTrustedProviders() external view returns (uint256 _price, uint256 _timestamp);\n\n    /**\n     * @notice Returns current asset price calculated from trusted providers and number of decimals\n     * @return _price                   Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\n     * @return _timestamp               Time when price was updated for the last time\n     * @return _assetPriceUsdDecimals   Number of decimals used for USD price\n     */\n    function getCurrentPriceWithDecimalsFromTrustedProviders() external view returns (\n        uint256 _price,\n        uint256 _timestamp,\n        uint256 _assetPriceUsdDecimals\n    );\n\n    /**\n     * @notice Returns current asset price details\n     * @return _price                                   Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\n     * @return _priceTimestamp                          Time when price was updated for the last time\n     * @return _priceFinalizationType                   Finalization type when price was updated for the last time\n     * @return _lastPriceEpochFinalizationTimestamp     Time when last price epoch was finalized\n     * @return _lastPriceEpochFinalizationType          Finalization type of last finalized price epoch\n     */\n    function getCurrentPriceDetails() external view returns (\n        uint256 _price,\n        uint256 _priceTimestamp,\n        PriceFinalizationType _priceFinalizationType,\n        uint256 _lastPriceEpochFinalizationTimestamp,\n        PriceFinalizationType _lastPriceEpochFinalizationType\n    );\n\n    /**\n     * @notice Returns current random number\n     */\n    function getCurrentRandom() external view returns (uint256);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston/ftso/userInterfaces/IFtsoManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\nimport \"../ftso/interface/IIFtso.sol\";\nimport \"../genesis/interface/IFtsoManagerGenesis.sol\";\n\ninterface IFtsoManager is IFtsoManagerGenesis {\n\n    event FtsoAdded(IIFtso ftso, bool add);\n    event FallbackMode(bool fallbackMode);\n    event FtsoFallbackMode(IIFtso ftso, bool fallbackMode);\n    event RewardEpochFinalized(uint256 votepowerBlock, uint256 startBlock);\n    event PriceEpochFinalized(address chosenFtso, uint256 rewardEpochId);\n    event InitializingCurrentEpochStateForRevealFailed(IIFtso ftso, uint256 epochId);\n    event FinalizingPriceEpochFailed(IIFtso ftso, uint256 epochId, IFtso.PriceFinalizationType failingType);\n    event DistributingRewardsFailed(address ftso, uint256 epochId);\n    event AccruingUnearnedRewardsFailed(uint256 epochId);\n    event UseGoodRandomSet(bool useGoodRandom, uint256 maxWaitForGoodRandomSeconds);\n\n    function active() external view returns (bool);\n\n    function getCurrentRewardEpoch() external view returns (uint256);\n\n    function getRewardEpochVotePowerBlock(uint256 _rewardEpoch) external view returns (uint256);\n\n    function getRewardEpochToExpireNext() external view returns (uint256);\n    \n    function getCurrentPriceEpochData() external view \n        returns (\n            uint256 _priceEpochId,\n            uint256 _priceEpochStartTimestamp,\n            uint256 _priceEpochEndTimestamp,\n            uint256 _priceEpochRevealEndTimestamp,\n            uint256 _currentTimestamp\n        );\n\n    function getFtsos() external view returns (IIFtso[] memory _ftsos);\n\n    function getPriceEpochConfiguration() external view \n        returns (\n            uint256 _firstPriceEpochStartTs,\n            uint256 _priceEpochDurationSeconds,\n            uint256 _revealEpochDurationSeconds\n        );\n\n    function getRewardEpochConfiguration() external view \n        returns (\n            uint256 _firstRewardEpochStartTs,\n            uint256 _rewardEpochDurationSeconds\n        );\n\n    function getFallbackMode() external view \n        returns (\n            bool _fallbackMode,\n            IIFtso[] memory _ftsos,\n            bool[] memory _ftsoInFallbackMode\n        );\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston/ftso/userInterfaces/IFtsoRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\npragma abicoder v2;\n\nimport \"../ftso/interface/IIFtso.sol\";\nimport \"../genesis/interface/IFtsoRegistryGenesis.sol\";\n\ninterface IFtsoRegistry is IFtsoRegistryGenesis {\n\n    struct PriceInfo {\n        uint256 ftsoIndex;\n        uint256 price;\n        uint256 decimals;\n        uint256 timestamp;\n    }\n\n    function getFtso(uint256 _ftsoIndex) external view returns(IIFtso _activeFtsoAddress);\n    function getFtsoBySymbol(string memory _symbol) external view returns(IIFtso _activeFtsoAddress);\n    function getSupportedIndices() external view returns(uint256[] memory _supportedIndices);\n    function getSupportedSymbols() external view returns(string[] memory _supportedSymbols);\n    function getSupportedFtsos() external view returns(IIFtso[] memory _ftsos);\n    function getFtsoIndex(string memory _symbol) external view returns (uint256 _assetIndex);\n    function getFtsoSymbol(uint256 _ftsoIndex) external view returns (string memory _symbol);\n    function getCurrentPrice(uint256 _ftsoIndex) external view returns(uint256 _price, uint256 _timestamp);\n    function getCurrentPrice(string memory _symbol) external view returns(uint256 _price, uint256 _timestamp);\n    function getCurrentPriceWithDecimals(uint256 _assetIndex) external view\n        returns(uint256 _price, uint256 _timestamp, uint256 _assetPriceUsdDecimals);\n    function getCurrentPriceWithDecimals(string memory _symbol) external view\n        returns(uint256 _price, uint256 _timestamp, uint256 _assetPriceUsdDecimals);\n\n    function getAllCurrentPrices() external view returns (PriceInfo[] memory);\n    function getCurrentPricesByIndices(uint256[] memory _indices) external view returns (PriceInfo[] memory);\n    function getCurrentPricesBySymbols(string[] memory _symbols) external view returns (PriceInfo[] memory);\n\n    function getSupportedIndicesAndFtsos() external view \n        returns(uint256[] memory _supportedIndices, IIFtso[] memory _ftsos);\n\n    function getSupportedSymbolsAndFtsos() external view \n        returns(string[] memory _supportedSymbols, IIFtso[] memory _ftsos);\n\n    function getSupportedIndicesAndSymbols() external view \n        returns(uint256[] memory _supportedIndices, string[] memory _supportedSymbols);\n\n    function getSupportedIndicesSymbolsAndFtsos() external view \n        returns(uint256[] memory _supportedIndices, string[] memory _supportedSymbols, IIFtso[] memory _ftsos);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston/ftso/userInterfaces/IFtsoRewardManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\ninterface IFtsoRewardManager {\n\n    event RewardClaimed(\n        address indexed dataProvider,\n        address indexed whoClaimed,\n        address indexed sentTo,\n        uint256 rewardEpoch, \n        uint256 amount\n    );\n\n    event UnearnedRewardsAccrued(\n        uint256 epochId,\n        uint256 reward\n    );\n\n    event RewardsDistributed(\n        address indexed ftso,\n        uint256 epochId,\n        address[] addresses,\n        uint256[] rewards\n    );\n\n    event RewardClaimsEnabled(\n        uint256 rewardEpochId\n    ); \n\n    event FeePercentageChanged(\n        address indexed dataProvider,\n        uint256 value,\n        uint256 validFromEpoch\n    );\n\n    event RewardClaimsExpired(\n        uint256 rewardEpochId\n    );    \n\n    event FtsoRewardManagerActivated(address ftsoRewardManager);\n    event FtsoRewardManagerDeactivated(address ftsoRewardManager);\n\n    /**\n     * @notice Allows a percentage delegator to claim rewards.\n     * @notice This function is intended to be used to claim rewards in case of delegation by percentage.\n     * @param _recipient            address to transfer funds to\n     * @param _rewardEpochs         array of reward epoch numbers to claim for\n     * @return _rewardAmount        amount of total claimed rewards\n     * @dev Reverts if `msg.sender` is delegating by amount\n     * @dev Claims for all unclaimed reward epochs to the 'max(_rewardEpochs)'.\n     * @dev Retained for backward compatibility.\n     * @dev This function is deprecated - use `claim` instead.\n     */\n    function claimReward(\n        address payable _recipient,\n        uint256[] calldata _rewardEpochs\n    )\n        external returns (uint256 _rewardAmount);\n\n    /**\n     * @notice Allows the sender to claim or wrap rewards for reward owner.\n     * @notice This function is intended to be used to claim rewards in case of delegation by percentage.\n     * @notice The caller does not have to be the owner, but must be approved by the owner to claim on his behalf,\n     *   this approval is done by calling `setClaimExecutors`.\n     * @notice It is actually safe for this to be called by anybody (nothing can be stolen), but by limiting who can\n     *   call, we allow the owner to control the timing of the calls.\n     * @notice Reward owner can claim to any `_recipient`, while the executor can only claim to the reward owner,\n     *   reward owners's personal delegation account or one of the addresses set by `setAllowedClaimRecipients`.\n     * @param _rewardOwner          address of the reward owner\n     * @param _recipient            address to transfer funds to\n     * @param _rewardEpoch          last reward epoch to claim for\n     * @param _wrap                 should reward be wrapped immediately\n     * @return _rewardAmount        amount of total claimed rewards\n     * @dev Reverts if `msg.sender` is delegating by amount\n     */\n    function claim(\n        address _rewardOwner,\n        address payable _recipient,\n        uint256 _rewardEpoch,\n        bool _wrap\n    )\n        external returns (uint256 _rewardAmount);\n    \n    /**\n     * @notice Allows the sender to claim rewards from specified data providers.\n     * @notice This function is intended to be used to claim rewards in case of delegation by amount.\n     * @param _recipient            address to transfer funds to\n     * @param _rewardEpochs         array of reward epoch numbers to claim for\n     * @param _dataProviders        array of addresses representing data providers to claim the reward from\n     * @return _rewardAmount        amount of total claimed rewards\n     * @dev Function can only be used for explicit delegations.\n     * @dev This function is deprecated - use `claimFromDataProviders` instead.\n     */\n    function claimRewardFromDataProviders(\n        address payable _recipient,\n        uint256[] calldata _rewardEpochs,\n        address[] calldata _dataProviders\n    )\n        external returns (uint256 _rewardAmount);\n\n    /**\n     * @notice Allows the sender to claim or wrap rewards for reward owner from specified data providers.\n     * @notice This function is intended to be used to claim rewards in case of delegation by amount.\n     * @notice The caller does not have to be the owner, but must be approved by the owner to claim on his behalf,\n     *   this approval is done by calling `setClaimExecutors`.\n     * @notice It is actually safe for this to be called by anybody (nothing can be stolen), but by limiting who can\n     *   call, we allow the owner to control the timing of the calls.\n     * @notice Reward owner can claim to any `_recipient`, while the executor can only claim to the reward owner,\n     *   reward owners's personal delegation account or one of the addresses set by `setAllowedClaimRecipients`.\n     * @param _rewardOwner          address of the reward owner\n     * @param _recipient            address to transfer funds to\n     * @param _rewardEpochs         array of reward epoch numbers to claim for\n     * @param _dataProviders        array of addresses representing data providers to claim the reward from\n     * @param _wrap                 should reward be wrapped immediately\n     * @return _rewardAmount        amount of total claimed rewards\n     * @dev Function can only be used for explicit delegations.\n     */\n    function claimFromDataProviders(\n        address _rewardOwner,\n        address payable _recipient,\n        uint256[] calldata _rewardEpochs,\n        address[] calldata _dataProviders,\n        bool _wrap\n    )\n        external returns (uint256 _rewardAmount);\n\n    /**\n     * @notice Allows batch claiming for the list of '_rewardOwners' and for all unclaimed epochs <= '_rewardEpoch'.\n     * @notice If reward owner has enabled delegation account, rewards are also claimed for that delegation account and\n     *   total claimed amount is sent to that delegation account, otherwise claimed amount is sent to owner's account.\n     * @notice Claimed amount is automatically wrapped.\n     * @notice Method can be used by reward owner or executor. If executor is registered with fee > 0,\n     *   then fee is paid to executor for each claimed address from the list.\n     * @param _rewardOwners         list of reward owners to claim for\n     * @param _rewardEpoch          last reward epoch to claim for\n     */\n    function autoClaim(address[] calldata _rewardOwners, uint256 _rewardEpoch) external;\n    \n    /**\n     * @notice Allows data provider to set (or update last) fee percentage.\n     * @param _feePercentageBIPS    number representing fee percentage in BIPS\n     * @return _validFromEpoch      reward epoch number when the setting becomes effective.\n     */\n    function setDataProviderFeePercentage(uint256 _feePercentageBIPS)\n        external returns (uint256 _validFromEpoch);\n\n    /**\n     * @notice Allows reward claiming\n     */\n    function active() external view returns (bool);\n\n    /**\n     * @notice Returns the current fee percentage of `_dataProvider`\n     * @param _dataProvider         address representing data provider\n     */\n    function getDataProviderCurrentFeePercentage(address _dataProvider)\n        external view returns (uint256 _feePercentageBIPS);\n\n    /**\n     * @notice Returns the fee percentage of `_dataProvider` at `_rewardEpoch`\n     * @param _dataProvider         address representing data provider\n     * @param _rewardEpoch          reward epoch number\n     */\n    function getDataProviderFeePercentage(\n        address _dataProvider,\n        uint256 _rewardEpoch\n    )\n        external view\n        returns (uint256 _feePercentageBIPS);\n\n    /**\n     * @notice Returns the scheduled fee percentage changes of `_dataProvider`\n     * @param _dataProvider         address representing data provider\n     * @return _feePercentageBIPS   positional array of fee percentages in BIPS\n     * @return _validFromEpoch      positional array of block numbers the fee settings are effective from\n     * @return _fixed               positional array of boolean values indicating if settings are subjected to change\n     */\n    function getDataProviderScheduledFeePercentageChanges(address _dataProvider) external view \n        returns (\n            uint256[] memory _feePercentageBIPS,\n            uint256[] memory _validFromEpoch,\n            bool[] memory _fixed\n        );\n\n    /**\n     * @notice Returns information on epoch reward\n     * @param _rewardEpoch          reward epoch number\n     * @return _totalReward         number representing the total epoch reward\n     * @return _claimedReward       number representing the amount of total epoch reward that has been claimed\n     */\n    function getEpochReward(uint256 _rewardEpoch) external view\n        returns (uint256 _totalReward, uint256 _claimedReward);\n\n    /**\n     * @notice Returns the state of rewards for `_beneficiary` at `_rewardEpoch`\n     * @param _beneficiary          address of reward beneficiary\n     * @param _rewardEpoch          reward epoch number\n     * @return _dataProviders       positional array of addresses representing data providers\n     * @return _rewardAmounts       positional array of reward amounts\n     * @return _claimed             positional array of boolean values indicating if reward is claimed\n     * @return _claimable           boolean value indicating if rewards are claimable\n     * @dev Reverts when queried with `_beneficiary` delegating by amount\n     */\n    function getStateOfRewards(\n        address _beneficiary,\n        uint256 _rewardEpoch\n    )\n        external view \n        returns (\n            address[] memory _dataProviders,\n            uint256[] memory _rewardAmounts,\n            bool[] memory _claimed,\n            bool _claimable\n        );\n\n    /**\n     * @notice Returns the state of rewards for `_beneficiary` at `_rewardEpoch` from `_dataProviders`\n     * @param _beneficiary          address of reward beneficiary\n     * @param _rewardEpoch          reward epoch number\n     * @param _dataProviders        positional array of addresses representing data providers\n     * @return _rewardAmounts       positional array of reward amounts\n     * @return _claimed             positional array of boolean values indicating if reward is claimed\n     * @return _claimable           boolean value indicating if rewards are claimable\n     */\n    function getStateOfRewardsFromDataProviders(\n        address _beneficiary,\n        uint256 _rewardEpoch,\n        address[] calldata _dataProviders\n    )\n        external view\n        returns (\n            uint256[] memory _rewardAmounts,\n            bool[] memory _claimed,\n            bool _claimable\n        );\n\n    /**\n     * @notice Returns the start and the end of the reward epoch range for which the reward is claimable\n     * @param _startEpochId         the oldest epoch id that allows reward claiming\n     * @param _endEpochId           the newest epoch id that allows reward claiming\n     */\n    function getEpochsWithClaimableRewards() external view \n        returns (\n            uint256 _startEpochId,\n            uint256 _endEpochId\n        );\n\n    /**\n     * @notice Returns the next claimable reward epoch for '_rewardOwner'.\n     * @param _rewardOwner          address of the reward owner\n     */\n    function nextClaimableRewardEpoch(address _rewardOwner) external view returns (uint256);\n\n    /**\n     * @notice Returns the array of claimable epoch ids for which the reward has not yet been claimed\n     * @param _beneficiary          address of reward beneficiary\n     * @return _epochIds            array of epoch ids\n     * @dev Reverts when queried with `_beneficiary` delegating by amount\n     */\n    function getEpochsWithUnclaimedRewards(address _beneficiary) external view returns (\n        uint256[] memory _epochIds\n    );\n\n    /**\n     * @notice Returns the information on claimed reward of `_dataProvider` for `_rewardEpoch` by `_claimer`\n     * @param _rewardEpoch          reward epoch number\n     * @param _dataProvider         address representing the data provider\n     * @param _claimer              address representing the claimer\n     * @return _claimed             boolean indicating if reward has been claimed\n     * @return _amount              number representing the claimed amount\n     */\n    function getClaimedReward(\n        uint256 _rewardEpoch,\n        address _dataProvider,\n        address _claimer\n    )\n        external view\n        returns (\n            bool _claimed,\n            uint256 _amount\n        );\n\n    /**\n     * @notice Return reward epoch that will expire, when new reward epoch will start\n     * @return Reward epoch id that will expire next\n     */\n    function getRewardEpochToExpireNext() external view returns (uint256);\n\n    /**\n     * @notice Return reward epoch vote power block\n     * @param _rewardEpoch          reward epoch number\n     */\n    function getRewardEpochVotePowerBlock(uint256 _rewardEpoch) external view returns (uint256);\n\n    /**\n     * @notice Return current reward epoch number\n     */\n    function getCurrentRewardEpoch() external view returns (uint256);\n\n    /**\n     * @notice Return initial reward epoch number\n     */\n    function getInitialRewardEpoch() external view returns (uint256);\n\n    /**\n     * @notice Returns the information on rewards and initial vote power of `_dataProvider` for `_rewardEpoch`\n     * @param _rewardEpoch                      reward epoch number\n     * @param _dataProvider                     address representing the data provider\n     * @return _rewardAmount                    number representing the amount of rewards\n     * @return _votePowerIgnoringRevocation     number representing the vote power ignoring revocations\n     */\n    function getDataProviderPerformanceInfo(\n        uint256 _rewardEpoch,\n        address _dataProvider\n    )\n        external view \n        returns (\n            uint256 _rewardAmount,\n            uint256 _votePowerIgnoringRevocation\n        );\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston/ftso/userInterfaces/IPriceSubmitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\nimport \"../genesis/interface/IFtsoGenesis.sol\";\nimport \"../genesis/interface/IFtsoRegistryGenesis.sol\";\n\ninterface IPriceSubmitter {\n    /**\n     * Event emitted when price hashes were submitted through PriceSubmitter.\n     * @param submitter the address of the sender\n     * @param epochId current price epoch id\n     * @param ftsos array of ftsos that correspond to the indexes in call\n     * @param hashes the submitted hashes\n     * @param timestamp current block timestamp\n     */\n    event PriceHashesSubmitted(\n        address indexed submitter,\n        uint256 indexed epochId,\n        IFtsoGenesis[] ftsos,\n        bytes32[] hashes,\n        uint256 timestamp\n    );\n\n    /**\n     * Event emitted when prices were revealed through PriceSubmitter.\n     * @param voter the address of the sender\n     * @param epochId id of the epoch in which the price hash was submitted\n     * @param ftsos array of ftsos that correspond to the indexes in the call\n     * @param prices the submitted prices\n     * @param timestamp current block timestamp\n     */\n    event PricesRevealed(\n        address indexed voter,\n        uint256 indexed epochId,\n        IFtsoGenesis[] ftsos,\n        uint256[] prices,\n        uint256[] randoms,\n        uint256 timestamp\n    );\n    \n    /**\n     * @notice Submits price hashes for current epoch\n     * @param _epochId              Target epoch id to which hashes are submitted\n     * @param _ftsoIndices          List of ftso indices\n     * @param _hashes               List of hashed price and random number\n     * @notice Emits PriceHashesSubmitted event\n     */\n    function submitPriceHashes(\n        uint256 _epochId,\n        uint256[] memory _ftsoIndices,\n        bytes32[] memory _hashes\n    ) external;\n\n    /**\n     * @notice Reveals submitted prices during epoch reveal period\n     * @param _epochId              Id of the epoch in which the price hashes was submitted\n     * @param _ftsoIndices          List of ftso indices\n     * @param _prices               List of submitted prices in USD\n     * @param _randoms              List of submitted random numbers\n     * @notice The hash of _price and _random must be equal to the submitted hash\n     * @notice Emits PricesRevealed event\n     */\n    function revealPrices(\n        uint256 _epochId,\n        uint256[] memory _ftsoIndices,\n        uint256[] memory _prices,\n        uint256[] memory _randoms\n    ) external;\n\n    /**\n     * Returns bitmap of all ftso's for which `_voter` is allowed to submit prices/hashes.\n     * If voter is allowed to vote for ftso at index (see *_FTSO_INDEX), the corrsponding\n     * bit in the result will be 1.\n     */    \n    function voterWhitelistBitmap(address _voter) external view returns (uint256);\n\n    function getVoterWhitelister() external view returns (address);\n    function getFtsoRegistry() external view returns (IFtsoRegistryGenesis);\n    function getFtsoManager() external view returns (address);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston/ftso/userInterfaces/IVoterWhitelister.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\ninterface IVoterWhitelister {\n    /**\n     * Raised when an account is removed from the voter whitelist.\n     */\n    event VoterWhitelisted(address voter, uint256 ftsoIndex);\n    \n    /**\n     * Raised when an account is removed from the voter whitelist.\n     */\n    event VoterRemovedFromWhitelist(address voter, uint256 ftsoIndex);\n\n    /**\n     * Raised when an account is chilled from the voter whitelist.\n     */\n    event VoterChilled(address voter, uint256 untilRewardEpoch);\n\n    /**\n     * Request to whitelist `_voter` account to ftso at `_ftsoIndex`. Will revert if vote power too low.\n     * May be called by any address.\n     */\n    function requestWhitelistingVoter(address _voter, uint256 _ftsoIndex) external;\n\n    /**\n     * Request to whitelist `_voter` account to all active ftsos.\n     * May be called by any address.\n     * It returns an array of supported ftso indices and success flag per index.\n     */\n    function requestFullVoterWhitelisting(\n        address _voter\n    ) \n        external \n        returns (\n            uint256[] memory _supportedIndices,\n            bool[] memory _success\n        );\n\n    /**\n     * Maximum number of voters in the whitelist for a new FTSO.\n     */\n    function defaultMaxVotersForFtso() external view returns (uint256);\n    \n    /**\n     * Maximum number of voters in the whitelist for FTSO at index `_ftsoIndex`.\n     */\n    function maxVotersForFtso(uint256 _ftsoIndex) external view returns (uint256);\n\n    /**\n     * Get whitelisted price providers for ftso with `_symbol`\n     */\n    function getFtsoWhitelistedPriceProvidersBySymbol(string memory _symbol) external view returns (address[] memory);\n\n    /**\n     * Get whitelisted price providers for ftso at `_ftsoIndex`\n     */\n    function getFtsoWhitelistedPriceProviders(uint256 _ftsoIndex) external view returns (address[] memory);\n\n    /**\n     * In case of providing bad prices (e.g. collusion), the voter can be chilled for a few reward epochs.\n     * A voter can whitelist again from a returned reward epoch onwards.\n     */\n    function chilledUntilRewardEpoch(address _voter) external view returns (uint256);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston/governance/userInterfaces/IGovernanceVotePower.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\ninterface IGovernanceVotePower {\n    /**\n     * @notice Delegate all governance vote power of `msg.sender` to `_to`.\n     * @param _to The address of the recipient\n     **/\n    function delegate(address _to) external;\n\n    /**\n     * @notice Undelegate all governance vote power of `msg.sender``.\n     **/\n    function undelegate() external;\n\n    /**\n    * @notice Get the governance vote power of `_who` at block `_blockNumber`\n    * @param _who The address to get voting power.\n    * @param _blockNumber The block number at which to fetch.\n    * @return _votePower    Governance vote power of `_who` at `_blockNumber`.\n    */\n    function votePowerOfAt(address _who, uint256 _blockNumber) external view returns(uint256);\n\n    /**\n    * @notice Get the vote power of `account` at the current block.\n    * @param account The address to get voting power.\n    * @return Vote power of `account` at the current block number.\n    */    \n    function getVotes(address account) external view returns (uint256);\n\n    /**\n    * @notice Get the delegate's address of `_who` at block `_blockNumber`\n    * @param _who The address to get delegate's address.\n    * @param _blockNumber The block number at which to fetch.\n    * @return Delegate's address of `_who` at `_blockNumber`.\n    */\n    function getDelegateOfAt(address _who, uint256 _blockNumber) external view returns (address);\n\n    /**\n    * @notice Get the delegate's address of `_who` at the current block.\n    * @param _who The address to get delegate's address.\n    * @return Delegate's address of `_who` at the current block number.\n    */    \n    function getDelegateOfAtNow(address _who) external  view returns (address);\n\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston/stateConnector/interface/AddressValidity.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\n/**\n * @custom:name AddressValidity\n * @custom:id 0x05\n * @custom:supported BTC, DOGE, XRP, testBTC, testDOGE, testXRP\n * @author Flare\n * @notice An assertion whether a string represents a valid address on an external chain.\n * @custom:verification The address is checked against all validity criteria of the chain with `sourceId`.\n * Indicator of validity is provided.\n * If the address is valid, its standard form and standard hash are computed.\n * Validity criteria for each supported chain:\n * - [BTC](/specs/attestations/external-chains/address-validity/BTC.md)\n * - [DOGE](/specs/attestations/external-chains/address-validity/DOGE.md)\n * - [XRPL](/specs/attestations/external-chains/address-validity/XRPL.md)\n * @custom:lut `0xffffffffffffffff` ($2^{64}-1$ in hex)\n */\ninterface AddressValidity {\n    /**\n     * @notice Toplevel request\n     * @param attestationType ID of the attestation type.\n     * @param sourceId Id of the data source.\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.\n     * @param requestBody Data defining the request. Type (struct) and interpretation is determined by the `attestationType`.\n     */\n    struct Request {\n        bytes32 attestationType;\n        bytes32 sourceId;\n        bytes32 messageIntegrityCode;\n        RequestBody requestBody;\n    }\n\n    /**\n     * @notice Toplevel response\n     * @param attestationType Extracted from the request.\n     * @param sourceId Extracted from the request.\n     * @param votingRound The ID of the State Connector round in which the request was considered.\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\n     * @param requestBody Extracted from the request.\n     * @param responseBody Data defining the response. The verification rules for the construction of the response body and the type are defined per specific `attestationType`.\n     */\n    struct Response {\n        bytes32 attestationType;\n        bytes32 sourceId;\n        uint64 votingRound;\n        uint64 lowestUsedTimestamp;\n        RequestBody requestBody;\n        ResponseBody responseBody;\n    }\n\n    /**\n     * @notice Toplevel proof\n     * @param merkleProof Merkle proof corresponding to the attestation response.\n     * @param data Attestation response.\n     */\n    struct Proof {\n        bytes32[] merkleProof;\n        Response data;\n    }\n\n    /**\n     * @notice Request body for AddressValidity attestation type\n     * @param addressStr Address to be verified.\n     */\n    struct RequestBody {\n        string addressStr;\n    }\n\n    /**\n     * @notice Response body for AddressValidity attestation type\n     * @param isValid Boolean indicator of the address validity.\n     * @param standardAddress If `isValid`, standard form of the validated address. Otherwise an empty string.\n     * @param standardAddressHash If `isValid`, standard address hash of the validated address. Otherwise a zero bytes32 string.\n     */\n    struct ResponseBody {\n        bool isValid;\n        string standardAddress;\n        bytes32 standardAddressHash;\n    }\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston/stateConnector/interface/BalanceDecreasingTransaction.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\n/**\n * @custom:name BalanceDecreasingTransaction\n * @custom:id 0x02\n * @custom:supported BTC, DOGE, XRP, testBTC, testDOGE, testXRP\n * @author Flare\n * @notice A detection of a transaction that either decreases the balance for some address or is signed by the source address.\n * Such an attestation could prove a violation of an agreement and therefore provides grounds to liquidate some funds locked by a smart contract on Flare.\n *\n * A transaction is considered “balance decreasing” for the address, if the balance after the transaction is lower than before or the address is among the signers of the transaction (even if its balance is greater than before the transaction).\n * @custom:verification The transaction with `transactionId` is fetched from the API of the source blockchain node or relevant indexer.\n * If the transaction cannot be fetched or the transaction is in a block that does not have a sufficient [number of confirmations](/specs/attestations/configs.md#finalityconfirmation), the attestation request is rejected.\n *\n * Once the transaction is received, the response fields are extracted if the transaction is balance decreasing for the indicated address.\n * Some of the request and response fields are chain specific as described below.\n * The fields can be computed with the help of a [balance decreasing summary](/specs/attestations/external-chains/transactions.md#balance-decreasing-summary).\n *\n * ### UTXO (Bitcoin and Dogecoin)\n *\n * - `sourceAddressIndicator` is the the index of the transaction input in hex padded to a 0x prefixed 32-byte string.\n * If the indicated input does not exist or the indicated input does not have the address, the attestation request is rejected.\n * The `sourceAddress` is the address of the indicated transaction input.\n * - `spentAmount` is the sum of values of all inputs with sourceAddress minus the sum of all outputs with `sourceAddress`.\n * Can be negative.\n * - `blockTimestamp` is the mediantime of a block.\n *\n * ### XRPL\n *\n * - `sourceAddressIndicator` is the [standard address hash](/specs/attestations/external-chains/standardAddress.md#standard-address-hash) of the address whose balance has been decreased.\n * If the address indicated by `sourceAddressIndicator` is not among the signers of the transaction and the balance of the address was not lowered in the transaction, the attestation request is rejected.\n *\n * - `spentAmount` is the difference between the balance of the indicated address after and before the transaction.\n * Can be negative.\n * - `blockTimestamp` is the close_time of a ledger converted to unix time.\n *\n * @custom:lut `blockTimestamp`\n */\ninterface BalanceDecreasingTransaction {\n    /**\n     * @notice Toplevel request\n     * @param attestationType ID of the attestation type.\n     * @param sourceId ID of the data source.\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.\n     * @param requestBody Data defining the request. Type (struct) and interpretation is determined by the `attestationType`.\n     */\n    struct Request {\n        bytes32 attestationType;\n        bytes32 sourceId;\n        bytes32 messageIntegrityCode;\n        RequestBody requestBody;\n    }\n\n    /**\n     * @notice Toplevel response\n     * @param attestationType Extracted from the request.\n     * @param sourceId Extracted from the request.\n     * @param votingRound The ID of the State Connector round in which the request was considered. This is a security measure to prevent a collision of attestation hashes.\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\n     * @param requestBody Extracted from the request.\n     * @param responseBody Data defining the response. The verification rules for the construction of the response body and the type are defined per specific `attestationType`.\n     */\n    struct Response {\n        bytes32 attestationType;\n        bytes32 sourceId;\n        uint64 votingRound;\n        uint64 lowestUsedTimestamp;\n        RequestBody requestBody;\n        ResponseBody responseBody;\n    }\n\n    /**\n     * @notice Toplevel proof\n     * @param merkleProof Merkle proof corresponding to the attestation response.\n     * @param data Attestation response.\n     */\n    struct Proof {\n        bytes32[] merkleProof;\n        Response data;\n    }\n\n    /**\n     * @notice Request body for BalanceDecreasingTransaction attestation type\n     * @param transactionId ID of the payment transaction.\n     * @param sourceAddressIndicator The indicator of the address whose balance has been decreased.\n     */\n    struct RequestBody {\n        bytes32 transactionId;\n        bytes32 sourceAddressIndicator;\n    }\n\n    /**\n     * @notice Response body for BalanceDecreasingTransaction attestation type.\n     * @param blockNumber The number of the block in which the transaction is included.\n     * @param blockTimestamp The timestamp of the block in which the transaction is included.\n     * @param sourceAddressHash Standard address hash of the address indicated by the `sourceAddressIndicator`.\n     * @param spentAmount Amount spent by the source address in minimal units.\n     * @param standardPaymentReference Standard payment reference of the transaction.\n     */\n    struct ResponseBody {\n        uint64 blockNumber;\n        uint64 blockTimestamp;\n        bytes32 sourceAddressHash;\n        int256 spentAmount;\n        bytes32 standardPaymentReference;\n    }\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston/stateConnector/interface/ConfirmedBlockHeightExists.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\n/**\n * @custom:name ConfirmedBlockHeightExists\n * @custom:id 0x02\n * @custom:supported BTC, DOGE, XRP, testBTC, testDOGE, testXRP\n * @author Flare\n * @notice An assertion that a block with `blockNumber` is confirmed.\n * It also provides data to compute the block production rate in the given time range.\n * @custom:verification It is checked that the block with `blockNumber` is confirmed by at least `numberOfConfirmations`.\n * If it is not, the request is rejected. We note a block on the tip of the chain is confirmed by 1 block.\n * Then `lowestQueryWindowBlock` is determined and its number and timestamp are extracted.\n *\n *\n *  Current confirmation heights consensus:\n *\n *\n * | `Chain` | `chainId` | `numberOfConfirmations` | `timestamp ` |\n * | ------- | --------- | ----------------------- | ------------ |\n * | `BTC`   | 0         | 6                       | mediantime   |\n * | `DOGE`  | 2         | 60                      | mediantime   |\n * | `XRP`   | 3         | 3                       | close_time   |\n *\n *\n *\n *\n * @custom:lut `lowestQueryWindowBlockTimestamp`\n */\ninterface ConfirmedBlockHeightExists {\n    /**\n     * @notice Toplevel request\n     * @param attestationType ID of the attestation type.\n     * @param sourceId ID of the data source.\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response as defined.\n     * @param requestBody Data defining the request. Type (struct) and interpretation is determined by the `attestationType`.\n     */\n    struct Request {\n        bytes32 attestationType;\n        bytes32 sourceId;\n        bytes32 messageIntegrityCode;\n        RequestBody requestBody;\n    }\n\n    /**\n     * @notice Toplevel response\n     * @param attestationType Extracted from the request.\n     * @param sourceId Extracted from the request.\n     * @param votingRound The ID of the State Connector round in which the request was considered.\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\n     * @param requestBody Extracted from the request.\n     * @param responseBody Data defining the response. The verification rules for the construction of the response body and the type are defined per specific `attestationType`.\n     */\n    struct Response {\n        bytes32 attestationType;\n        bytes32 sourceId;\n        uint64 votingRound;\n        uint64 lowestUsedTimestamp;\n        RequestBody requestBody;\n        ResponseBody responseBody;\n    }\n\n    /**\n     * @notice Toplevel proof\n     * @param merkleProof Merkle proof corresponding to the attestation response.\n     * @param data Attestation response.\n     */\n    struct Proof {\n        bytes32[] merkleProof;\n        Response data;\n    }\n\n    /**\n     * @notice Request body for ConfirmedBlockHeightExistsType attestation type\n     * @param blockNumber The number of the block the request wants a confirmation of.\n     * @param queryWindow The length of the period in which the block production rate is to be computed.\n     */\n    struct RequestBody {\n        uint64 blockNumber;\n        uint64 queryWindow;\n    }\n\n    /**\n     * @notice Response body for ConfirmedBlockHeightExistsType attestation type\n     * @custom:below `blockNumber`, `lowestQueryWindowBlockNumber`, `blockTimestamp` and `lowestQueryWindowBlockTimestamp` can be used to compute the average block production time in the specified block range.\n     * @param blockTimestamp The timestamp of the block with `blockNumber`.\n     * @param numberOfConfirmations The depth at which a block is considered confirmed depending on the chain. All attestation providers must agree on this number.\n     * @param lowestQueryWindowBlockNumber The block number of the latest block that has a timestamp strictly smaller than `blockTimestamp` - `queryWindow`.\n     * @param lowestQueryWindowBlockTimestamp The timestamp of the block at height `lowestQueryWindowBlockNumber`.\n     */\n    struct ResponseBody {\n        uint64 blockTimestamp;\n        uint64 numberOfConfirmations;\n        uint64 lowestQueryWindowBlockNumber;\n        uint64 lowestQueryWindowBlockTimestamp;\n    }\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston/stateConnector/interface/EVMTransaction.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\n/**\n * @custom:name EVMTransaction\n * @custom:id 0x06\n * @custom:supported ETH, FLR, SGB, testETH, testFLR, testSGB\n * @author Flare\n * @notice A relay of a transaction from an EVM chain.\n * This type is only relevant for EVM-compatible chains.\n * @custom:verification If a transaction with the `transactionId` is in a block on the main branch with at least `requiredConfirmations`, the specified data is relayed.\n * If an indicated event does not exist, the request is rejected.\n * @custom:lut `timestamp`\n */\ninterface EVMTransaction {\n    /**\n     * @notice Toplevel request\n     * @param attestationType ID of the attestation type.\n     * @param sourceId  ID of the data source.\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.\n     * @param requestBody Data defining the request. Type (struct) and interpretation is determined by the `attestationType`.\n     */\n    struct Request {\n        bytes32 attestationType;\n        bytes32 sourceId;\n        bytes32 messageIntegrityCode;\n        RequestBody requestBody;\n    }\n\n    /**\n     * @notice Toplevel response\n     * @param attestationType Extracted from the request.\n     * @param sourceId Extracted from the request.\n     * @param votingRound The ID of the State Connector round in which the request was considered.\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\n     * @param requestBody Extracted from the request.\n     * @param responseBody Data defining the response. The verification rules for the construction of the response body and the type are defined per specific `attestationType`.\n     */\n    struct Response {\n        bytes32 attestationType;\n        bytes32 sourceId;\n        uint64 votingRound;\n        uint64 lowestUsedTimestamp;\n        RequestBody requestBody;\n        ResponseBody responseBody;\n    }\n\n    /**\n     * @notice Toplevel proof\n     * @param merkleProof Merkle proof corresponding to the attestation response.\n     * @param data Attestation response.\n     */\n    struct Proof {\n        bytes32[] merkleProof;\n        Response data;\n    }\n\n    /**\n     * @notice Request body for EVM transaction attestation type\n     * @custom:below Note that events (logs) are indexed in block not in each transaction. The contract that uses the attestation should specify the order of event logs as needed and the requestor should sort `logIndices`\n     * with respect to the set specifications. If possible, the contact should only require one `logIndex`.\n     * @param transactionHash Hash of the transaction(transactionHash).\n     * @param requiredConfirmations The height at which a block is considered confirmed by the requestor.\n     * @param provideInput If true, \"input\" field is included in the response.\n     * @param listEvents If true, events indicated by `logIndices` are included in the response. Otherwise, no events are included in the response.\n     * @param logIndices If `listEvents` is `false`, this should be an empty list, otherwise, the request is rejected. If `listEvents` is `true`, this is the list of indices (logIndex) of the events to be relayed (sorted by the requestor). The array should contain at most 50 indices. If empty, it indicates all events in order capped by 50.\n     */\n    struct RequestBody {\n        bytes32 transactionHash;\n        uint16 requiredConfirmations;\n        bool provideInput;\n        bool listEvents;\n        uint32[] logIndices;\n    }\n\n    /**\n     * @notice Response body for EVM transaction attestation type\n     * @custom:below The fields are in line with [transaction](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_gettransactionbyhash) provided by EVM node.\n     * @param blockNumber Number of the block in which the transaction is included.\n     * @param timestamp Timestamp of the block in which the transaction is included.\n     * @param sourceAddress The address (from) that signed the transaction.\n     * @param isDeployment Indicate whether it is a contract creation transaction.\n     * @param receivingAddress The address (to) of the receiver of the initial transaction. Zero address if `isDeployment` is `true`.\n     * @param value The value transferred by the initial transaction in wei.\n     * @param input If `provideInput`, this is the data send along with the initial transaction. Otherwise it is the default value `0x00`.\n     * @param status Status of the transaction 1 - success, 0 - failure.\n     * @param events If `listEvents` is `true`, an array of the requested events. Sorted by the logIndex in the same order as `logIndices`. Otherwise, an empty array.\n     */\n    struct ResponseBody {\n        uint64 blockNumber;\n        uint64 timestamp;\n        address sourceAddress;\n        bool isDeployment;\n        address receivingAddress;\n        uint256 value;\n        bytes input;\n        uint8 status;\n        Event[] events;\n    }\n\n    /**\n     * @notice Event log record\n     * @custom:above An `Event` is a struct with the following fields:\n     * @custom:below The fields are in line with [EVM event logs](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getfilterchanges).\n     * @param logIndex The consecutive number of the event in block.\n     * @param emitterAddress The address of the contract that emitted the event.\n     * @param topics An array of up to four 32-byte strings of indexed log arguments.\n     * @param data Concatenated 32-byte strings of non-indexed log arguments. At least 32 bytes long.\n     * @param removed It is `true` if the log was removed due to a chain reorganization and `false` if it is a valid log.\n     */\n    struct Event {\n        uint32 logIndex;\n        address emitterAddress;\n        bytes32[] topics;\n        bytes data;\n        bool removed;\n    }\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston/stateConnector/interface/IAddressValidityVerification.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\nimport \"./AddressValidity.sol\";\n\ninterface IAddressValidityVerification {\n\n   function verifyAddressValidity(\n      AddressValidity.Proof calldata _proof\n   ) external view returns (bool _proved);\n}\n   "
    },
    "@flarenetwork/flare-periphery-contracts/coston/stateConnector/interface/IBalanceDecreasingTransactionVerification.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\nimport \"./BalanceDecreasingTransaction.sol\";\n\ninterface IBalanceDecreasingTransactionVerification {\n\n   function verifyBalanceDecreasingTransaction(\n      BalanceDecreasingTransaction.Proof calldata _proof\n   ) external view returns (bool _proved);\n}\n   "
    },
    "@flarenetwork/flare-periphery-contracts/coston/stateConnector/interface/IConfirmedBlockHeightExistsVerification.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\nimport \"./ConfirmedBlockHeightExists.sol\";\n\ninterface IConfirmedBlockHeightExistsVerification {\n\n   function verifyConfirmedBlockHeightExists(\n      ConfirmedBlockHeightExists.Proof calldata _proof\n   ) external view returns (bool _proved);\n}\n   "
    },
    "@flarenetwork/flare-periphery-contracts/coston/stateConnector/interface/IEVMTransactionVerification.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\nimport \"./EVMTransaction.sol\";\n\ninterface IEVMTransactionVerification {\n\n   function verifyEVMTransaction(\n      EVMTransaction.Proof calldata _proof\n   ) external view returns (bool _proved);\n}\n   "
    },
    "@flarenetwork/flare-periphery-contracts/coston/stateConnector/interface/IPaymentVerification.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\nimport \"./Payment.sol\";\n\ninterface IPaymentVerification {\n\n   function verifyPayment(\n      Payment.Proof calldata _proof\n   ) external view returns (bool _proved);\n}\n   "
    },
    "@flarenetwork/flare-periphery-contracts/coston/stateConnector/interface/IReferencedPaymentNonexistenceVerification.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\nimport \"./ReferencedPaymentNonexistence.sol\";\n\ninterface IReferencedPaymentNonexistenceVerification {\n\n   function verifyReferencedPaymentNonexistence(\n      ReferencedPaymentNonexistence.Proof calldata _proof\n   ) external view returns (bool _proved);\n}\n   "
    },
    "@flarenetwork/flare-periphery-contracts/coston/stateConnector/interface/IStateConnector.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\n// solhint-disable func-name-mixedcase\ninterface IStateConnector {\n    event AttestationRequest(\n        address sender,\n        uint256 timestamp,\n        bytes data\n    );\n\n    event RoundFinalised(\n        uint256 indexed roundId,\n        bytes32 merkleRoot\n    );\n\n    /**\n     * The method to call for requesting a new attestation.\n     * Emits event `AttestationRequest`, which triggers work by attestation providers.\n     */\n    function requestAttestations(bytes calldata _data) external;\n\n    /**\n     * Last finalized round id.\n     */\n    function lastFinalizedRoundId() external view returns (uint256 _roundId);\n\n    /**\n     * Get Merkle root for the round and check for buffer overflows.\n     */\n    function merkleRoot(uint256 _roundId) external view returns (bytes32);\n\n    /**\n     * The first buffer timestamp\n     * (start time in seconds for converting the timestamp into a round number).\n     */\n    function BUFFER_TIMESTAMP_OFFSET() external view returns (uint256);\n\n    /**\n     * Amount of time a buffer is active before cycling to the next one\n     * (round length in seconds for converting the timestamp into a round number).\n     */\n    function BUFFER_WINDOW() external view returns (uint256);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston/stateConnector/interface/Payment.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\n/**\n * @custom:name Payment\n * @custom:id 0x01\n * @custom:supported BTC, DOGE, XRP, testBTC, testDOGE, testXRP\n * @author Flare\n * @notice A relay of a transaction on an external chain that is considered a payment in a native currency.\n * Various blockchains support different types of native payments. For each blockchain, it is specified how a payment\n * transaction should be formed to be provable by this attestation type.\n * The provable payments emulate traditional banking payments from entity A to entity B in native currency with an optional payment reference.\n * @custom:verification The transaction with `transactionId` is fetched from the API of the blockchain node or relevant indexer.\n * If the transaction cannot be fetched or the transaction is in a block that does not have a sufficient [number of confirmations](/specs/attestations/configs.md#finalityconfirmation), the attestation request is rejected.\n *\n * Once the transaction is received, the [payment summary](/specs/attestations/external-chains/transactions.md#payment-summary) is computed according to the rules for the source chain.\n * If the summary is successfully calculated, the response is assembled from the summary.\n * `blockNumber` and `blockTimestamp` are retrieved from the block if they are not included in the transaction data.\n * For Bitcoin and Dogecoin, `blockTimestamp` is mediantime of the block.\n * For XRPL, `blockTimestamp` is close time of the ledger converted to UNIX time.\n *\n * If the summary is not successfully calculated, the attestation request is rejected.\n * @custom:lut `blockTimestamp`\n */\ninterface Payment {\n    /**\n     * @notice Toplevel request\n     * @param attestationType ID of the attestation type.\n     * @param sourceId ID of the data source.\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.\n     * @param requestBody Data defining the request. Type (struct) and interpretation is determined by the `attestationType`.\n     */\n    struct Request {\n        bytes32 attestationType;\n        bytes32 sourceId;\n        bytes32 messageIntegrityCode;\n        RequestBody requestBody;\n    }\n\n    /**\n     * @notice Toplevel response\n     * @param attestationType Extracted from the request.\n     * @param sourceId Extracted from the request.\n     * @param votingRound The ID of the State Connector round in which the request was considered.\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\n     * @param requestBody Extracted from the request.\n     * @param responseBody Data defining the response. The verification rules for the construction of the response body and the type are defined per specific `attestationType`.\n     */\n    struct Response {\n        bytes32 attestationType;\n        bytes32 sourceId;\n        uint64 votingRound;\n        uint64 lowestUsedTimestamp;\n        RequestBody requestBody;\n        ResponseBody responseBody;\n    }\n\n    /**\n     * @notice Toplevel proof\n     * @param merkleProof Merkle proof corresponding to the attestation response.\n     * @param data Attestation response.\n     */\n    struct Proof {\n        bytes32[] merkleProof;\n        Response data;\n    }\n\n    /**\n     * @notice Request body for Payment attestation type\n     * @param transactionId ID of the payment transaction.\n     * @param inUtxo For UTXO chains, this is the index of the transaction input with source address. Always 0 for the non-utxo chains.\n     * @param utxo For UTXO chains, this is the index of the transaction output with receiving address. Always 0 for the non-utxo chains.\n     */\n    struct RequestBody {\n        bytes32 transactionId;\n        uint256 inUtxo;\n        uint256 utxo;\n    }\n\n    /**\n     * @notice Response body for Payment attestation type\n     * @param blockNumber Number of the block in which the transaction is included.\n     * @param blockTimestamp The timestamp of the block in which the transaction is included.\n     * @param sourceAddressHash Standard address hash of the source address.\n     * @param receivingAddressHash Standard address hash of the receiving address. The zero 32-byte string if there is no receivingAddress (if `status` is not success).\n     * @param intendedReceivingAddressHash Standard address hash of the intended receiving address. Relevant if the transaction is unsuccessful.\n     * @param spentAmount Amount in minimal units spent by the source address.\n     * @param intendedSpentAmount Amount in minimal units to be spent by the source address. Relevant if the transaction status is unsuccessful.\n     * @param receivedAmount Amount in minimal units received by the receiving address.\n     * @param intendedReceivedAmount Amount in minimal units intended to be received by the receiving address. Relevant if the transaction is unsuccessful.\n     * @param standardPaymentReference [Standard payment reference](/specs/attestations/external-chains/standardPaymentReference.md) of the transaction.\n     * @param oneToOne Indicator whether only one source and one receiver are involved in the transaction.\n     * @param status  [Succes status](/specs/attestations/external-chains/transactions.md#transaction-success-status) of the transaction: 0 - success, 1 - failed by sender's fault,x  2 - failed by receiver's fault.\n     */\n    struct ResponseBody {\n        uint64 blockNumber;\n        uint64 blockTimestamp;\n        bytes32 sourceAddressHash;\n        bytes32 receivingAddressHash;\n        bytes32 intendedReceivingAddressHash;\n        int256 spentAmount;\n        int256 intendedSpentAmount;\n        int256 receivedAmount;\n        int256 intendedReceivedAmount;\n        bytes32 standardPaymentReference;\n        bool oneToOne;\n        uint8 status;\n    }\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston/stateConnector/interface/ReferencedPaymentNonexistence.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\n/**\n * @custom:name ReferencedPaymentNonexistence\n * @custom:id 0x04\n * @custom:supported BTC, DOGE, XRP, testBTC, testDOGE, testXRP\n * @author Flare\n * @notice Assertion that an agreed-upon payment has not been made by a certain deadline.\n * A confirmed request shows that a transaction meeting certain criteria (address, amount, reference) did not appear in the specified block range.\n * \n * \n * This type of attestation can be used to e.g. provide grounds to liquidate funds locked by a smart contract on Flare when a payment is missed. \n *\n * @custom:verification If `firstOverflowBlock` cannot be determined or does not have a sufficient [number of confirmations](/specs/attestations/configs.md#finalityconfirmation), the attestation request is rejected.\n * If `firstOverflowBlockNumber` is higher or equal to `minimalBlockNumber`, the request is rejected.\n * The search range are blocks between heights including `minimalBlockNumber` and excluding `firstOverflowBlockNumber`.\n * If the verifier does not have a view of all blocks from `minimalBlockNumber` to `firstOverflowBlockNumber`, the attestation request is rejected.\n *\n * The request is confirmed if no transaction meeting the specified criteria is found in the search range.\n * The criteria and timestamp are chain specific.\n * ### UTXO (Bitcoin and Dogecoin)\n *\n *\n * Criteria for the transaction:\n *\n *\n * - It is not coinbase transaction.\n * - The transaction has the specified [standardPaymentReference](/specs/attestations/external-chains/standardPaymentReference.md#btc-and-doge-blockchains).\n * - The sum of values of all outputs with the specified address minus the sum of values of all inputs with the specified address is greater than `amount` (in practice the sum of all values of the inputs with the specified address is zero).\n *\n * \n * Timestamp is `mediantime`.\n\n * ### XRPL\n *\n *\n *\n * Criteria for the transaction:\n * - The transaction is of type payment.\n * - The transaction has the specified [standardPaymentReference](/specs/attestations/external-chains/standardPaymentReference.md#xrp),\n * - One of the following is true:\n *   - Transaction status is `SUCCESS` and the amount received by the specified destination address is greater than the specified `value`.\n *   - Transaction status is `RECEIVER_FAILURE` and the specified destination address would receive an amount greater than the specified `value` had the transaction been successful.\n *\n * \n * Timestamp is `close_time` converted to UNIX time.\n *\n * @custom:lut `minimalBlockTimestamp`\n */\ninterface ReferencedPaymentNonexistence {\n    /**\n     * @notice Toplevel request\n     * @param attestationType ID of the attestation type.\n     * @param sourceId ID of the data source.\n     * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response as defined.\n     * @param requestBody Data defining the request. Type (struct) and interpretation is determined by the `attestationType`.\n     */\n    struct Request {\n        bytes32 attestationType;\n        bytes32 sourceId;\n        bytes32 messageIntegrityCode;\n        RequestBody requestBody;\n    }\n\n    /**\n     * @notice Toplevel response\n     * @param attestationType Extracted from the request.\n     * @param sourceId Extracted from the request.\n     * @param votingRound The ID of the State Connector round in which the request was considered.\n     * @param lowestUsedTimestamp The lowest timestamp used to generate the response.\n     * @param requestBody Extracted from the request.\n     * @param responseBody Data defining the response. The verification rules for the construction of the response body and the type are defined per specific `attestationType`.\n     */\n    struct Response {\n        bytes32 attestationType;\n        bytes32 sourceId;\n        uint64 votingRound;\n        uint64 lowestUsedTimestamp;\n        RequestBody requestBody;\n        ResponseBody responseBody;\n    }\n\n    /**\n     * @notice Toplevel proof\n     * @param merkleProof Merkle proof corresponding to the attestation response.\n     * @param data Attestation response.\n     */\n    struct Proof {\n        bytes32[] merkleProof;\n        Response data;\n    }\n\n    /**\n     * @notice Request body for ReferencePaymentNonexistence attestation type\n     * @param minimalBlockNumber The start block of the search range.\n     * @param deadlineBlockNumber The blockNumber to be included in the search range.\n     * @param deadlineTimestamp The timestamp to be included in the search range.\n     * @param destinationAddressHash The standard address hash of the address to which the payment had to be done.\n     * @param amount The requested amount in minimal units that had to be payed.\n     * @param standardPaymentReference The requested standard payment reference.\n     * @custom:below The `standardPaymentReference` should not be zero (as a 32-byte sequence).\n     */\n    struct RequestBody {\n        uint64 minimalBlockNumber;\n        uint64 deadlineBlockNumber;\n        uint64 deadlineTimestamp;\n        bytes32 destinationAddressHash;\n        uint256 amount;\n        bytes32 standardPaymentReference;\n    }\n\n    /**\n     * @notice Response body for ReferencePaymentNonexistence attestation type.\n     * @param minimalBlockTimestamp The timestamp of the minimalBlock.\n     * @param firstOverflowBlockNumber The height of the firstOverflowBlock.\n     * @param firstOverflowBlockTimestamp The timestamp of the firstOverflowBlock.\n     * @custom:below `firstOverflowBlock` is the first block that has block number higher than `deadlineBlockNumber` and timestamp later than `deadlineTimestamp`.\n     * The specified search range are blocks between heights including `minimalBlockNumber` and excluding `firstOverflowBlockNumber`.\n     */\n    struct ResponseBody {\n        uint64 minimalBlockTimestamp;\n        uint64 firstOverflowBlockNumber;\n        uint64 firstOverflowBlockTimestamp;\n    }\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston/util-contracts/ContractRegistryLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IFlareContractRegistry} from \"./userInterfaces/IFlareContractRegistry.sol\";\n// Auto generated imports\n// AUTO GENERATED - DO NOT EDIT BELOW THIS LINE\nimport { IStateConnector } from \"../stateConnector/interface/IStateConnector.sol\";\nimport { IPriceSubmitter } from \"../ftso/userInterfaces/IPriceSubmitter.sol\";\nimport { IFtsoRewardManager } from \"../ftso/userInterfaces/IFtsoRewardManager.sol\";\nimport { IFtsoRegistry } from \"../ftso/userInterfaces/IFtsoRegistry.sol\";\nimport { IVoterWhitelister } from \"../ftso/userInterfaces/IVoterWhitelister.sol\";\nimport { IFtsoManager } from \"../ftso/userInterfaces/IFtsoManager.sol\";\nimport { IWNat } from \"../util-contracts/token/userInterfaces/IWNat.sol\";\nimport { IEVMTransactionVerification } from \"../stateConnector/interface/IEVMTransactionVerification.sol\";\nimport { IAddressValidityVerification } from \"../stateConnector/interface/IAddressValidityVerification.sol\";\nimport { IBalanceDecreasingTransactionVerification } from \"../stateConnector/interface/IBalanceDecreasingTransactionVerification.sol\";\nimport { IConfirmedBlockHeightExistsVerification } from \"../stateConnector/interface/IConfirmedBlockHeightExistsVerification.sol\";\nimport { IPaymentVerification } from \"../stateConnector/interface/IPaymentVerification.sol\";\nimport { IReferencedPaymentNonexistenceVerification } from \"../stateConnector/interface/IReferencedPaymentNonexistenceVerification.sol\"; \n// END AUTO GENERATED - DO NOT EDIT ABOVE THIS LINE\n\n// Library is intended to be used inline, so the strings are all memory allocated (instead of calldata)\nlibrary FlareContractsRegistryLibrary {\n    address internal constant FLARE_CONTRACT_REGISTRY_ADDRESS =\n        0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019;\n\n    IFlareContractRegistry internal constant FLARE_CONTRACT_REGISTRY =\n        IFlareContractRegistry(FLARE_CONTRACT_REGISTRY_ADDRESS);\n\n    /**\n     * @notice Returns contract address for the given name - might be address(0)\n     * @param _name             name of the contract\n     */\n    function getContractAddressByName(\n        string memory _name\n    ) internal view returns (address) {\n        return FLARE_CONTRACT_REGISTRY.getContractAddressByName(_name);\n    }\n\n    /**\n     * @notice Returns contract address for the given name hash - might be address(0)\n     * @param _nameHash         hash of the contract name (keccak256(abi.encode(name))\n     */\n    function getContractAddressByHash(\n        bytes32 _nameHash\n    ) internal view returns (address) {\n        return FLARE_CONTRACT_REGISTRY.getContractAddressByHash(_nameHash);\n    }\n\n    /**\n     * @notice Returns contract addresses for the given names - might be address(0)\n     * @param _names            names of the contracts\n     */\n    function getContractAddressesByName(\n        string[] memory _names\n    ) internal view returns (address[] memory) {\n        return FLARE_CONTRACT_REGISTRY.getContractAddressesByName(_names);\n    }\n\n    /**\n     * @notice Returns contract addresses for the given name hashes - might be address(0)\n     * @param _nameHashes       hashes of the contract names (keccak256(abi.encode(name))\n     */\n    function getContractAddressesByHash(\n        bytes32[] memory _nameHashes\n    ) internal view returns (address[] memory) {\n        return FLARE_CONTRACT_REGISTRY.getContractAddressesByHash(_nameHashes);\n    }\n\n    /**\n     * @notice Returns all contract names and corresponding addresses\n     */\n    function getAllContracts()\n        internal\n        view\n        returns (string[] memory _names, address[] memory _addresses)\n    {\n        return FLARE_CONTRACT_REGISTRY.getAllContracts();\n    }\n\n    // Nice typed getters for all the important contracts\n    // AUTO GENERATED - DO NOT EDIT BELOW THIS LINE\n    function getStateConnector() internal view returns(IStateConnector){\nreturn IStateConnector(FLARE_CONTRACT_REGISTRY.getContractAddressByName(\"StateConnector\"));\n\n}\n\n\nfunction getPriceSubmitter() internal view returns(IPriceSubmitter){\nreturn IPriceSubmitter(FLARE_CONTRACT_REGISTRY.getContractAddressByName(\"PriceSubmitter\"));\n\n}\n\n\nfunction getFtsoRewardManager() internal view returns(IFtsoRewardManager){\nreturn IFtsoRewardManager(FLARE_CONTRACT_REGISTRY.getContractAddressByName(\"FtsoRewardManager\"));\n\n}\n\n\nfunction getFtsoRegistry() internal view returns(IFtsoRegistry){\nreturn IFtsoRegistry(FLARE_CONTRACT_REGISTRY.getContractAddressByName(\"FtsoRegistry\"));\n\n}\n\n\nfunction getVoterWhitelister() internal view returns(IVoterWhitelister){\nreturn IVoterWhitelister(FLARE_CONTRACT_REGISTRY.getContractAddressByName(\"VoterWhitelister\"));\n\n}\n\n\nfunction getFtsoManager() internal view returns(IFtsoManager){\nreturn IFtsoManager(FLARE_CONTRACT_REGISTRY.getContractAddressByName(\"FtsoManager\"));\n\n}\n\n\nfunction getWNat() internal view returns(IWNat){\nreturn IWNat(FLARE_CONTRACT_REGISTRY.getContractAddressByName(\"WNat\"));\n\n}\n\n\n// Returns hardcoded unofficial deployment instances of Flare core contracts\nfunction auxiliaryGetIEVMTransactionVerification() internal view returns(IEVMTransactionVerification){\nreturn IEVMTransactionVerification(0xf37AD1278917c04fb291C75a42e61710964Cb57c);\n\n}\n\n\n// Returns hardcoded unofficial deployment instances of Flare core contracts\nfunction auxiliaryGetIAddressValidityVerification() internal view returns(IAddressValidityVerification){\nreturn IAddressValidityVerification(0xd94721da1dD5e222020D256fC073e8Be301ebdCB);\n\n}\n\n\n// Returns hardcoded unofficial deployment instances of Flare core contracts\nfunction auxiliaryGetIBalanceDecreasingTransactionVerification() internal view returns(IBalanceDecreasingTransactionVerification){\nreturn IBalanceDecreasingTransactionVerification(0xeDa84A2eeDfdA53e7c33ef5fDe7B2798B910BF4A);\n\n}\n\n\n// Returns hardcoded unofficial deployment instances of Flare core contracts\nfunction auxiliaryGetIConfirmedBlockHeightExistsVerification() internal view returns(IConfirmedBlockHeightExistsVerification){\nreturn IConfirmedBlockHeightExistsVerification(0x632A984d63f9Ae3C2Eb31e0dc2EeEaE1E282E0da);\n\n}\n\n\n// Returns hardcoded unofficial deployment instances of Flare core contracts\nfunction auxiliaryGetIPaymentVerification() internal view returns(IPaymentVerification){\nreturn IPaymentVerification(0x1ECe6dd08D19c0faf3AB8cEcB146cd5ea5b9b7d9);\n\n}\n\n\n// Returns hardcoded unofficial deployment instances of Flare core contracts\nfunction auxiliaryGetIReferencedPaymentNonexistenceVerification() internal view returns(IReferencedPaymentNonexistenceVerification){\nreturn IReferencedPaymentNonexistenceVerification(0xDfE5926fABA166187B29C33BC95DfDb18bbE52cd);\n\n}\n \n    // END AUTO GENERATED - DO NOT EDIT ABOVE THIS LINE\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston/util-contracts/token/token/interface/IICleanable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\ninterface IICleanable {\n    /**\n     * Set the contract that is allowed to call history cleaning methods.\n     */\n    function setCleanerContract(address _cleanerContract) external;\n    \n    /**\n     * Set the cleanup block number.\n     * Historic data for the blocks before `cleanupBlockNumber` can be erased,\n     * history before that block should never be used since it can be inconsistent.\n     * In particular, cleanup block number must be before current vote power block.\n     * @param _blockNumber The new cleanup block number.\n     */\n    function setCleanupBlockNumber(uint256 _blockNumber) external;\n    \n    /**\n     * Set the contract that is allowed to set cleanupBlockNumber.\n     * Usually this will be an instance of CleanupBlockNumberManager.\n     */\n    function setCleanupBlockNumberManager(address _cleanupBlockNumberManager) external;\n    \n    /**\n     * Get the current cleanup block number.\n     */\n    function cleanupBlockNumber() external view returns (uint256);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston/util-contracts/token/token/interface/IIGovernanceVotePower.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\nimport \"../../userInterfaces/IVPToken.sol\";\nimport \"../../../../governance/userInterfaces/IGovernanceVotePower.sol\";\n\ninterface IIGovernanceVotePower is IGovernanceVotePower {\n    /**\n     * Event triggered when an delegator's balance changes.\n     *\n     * Note: the event is always emitted from `GovernanceVotePower`.\n     */\n    event DelegateVotesChanged(\n    address indexed delegate, \n    uint256 previousBalance, \n    uint256 newBalance\n    );\n\n    /**\n     * Event triggered when an account delegates to another account.\n     *\n     * Note: the event is always emitted from `GovernanceVotePower`.\n     */\n    event DelegateChanged(\n    address indexed delegator, \n    address indexed fromDelegate, \n    address indexed toDelegate\n    );\n\n    /**\n     * Update vote powers when tokens are transferred.\n     **/\n    function updateAtTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _fromBalance,\n        uint256 _toBalance,\n        uint256 _amount\n    ) external;\n\n    /**\n     * Set the cleanup block number.\n     * Historic data for the blocks before `cleanupBlockNumber` can be erased,\n     * history before that block should never be used since it can be inconsistent.\n     * In particular, cleanup block number must be before current vote power block.\n     * @param _blockNumber The new cleanup block number.\n     */\n    function setCleanupBlockNumber(uint256 _blockNumber) external;\n\n    /**\n     * Set the contract that is allowed to call history cleaning methods.\n     */\n    function setCleanerContract(address _cleanerContract) external;\n\n    /**\n     * @notice Get the token that this governance vote power contract belongs to.\n     */\n    function ownerToken() external view returns (IVPToken);\n\n    function getCleanupBlockNumber() external view returns(uint256);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston/util-contracts/token/token/interface/IIVPContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\nimport \"../../userInterfaces/IVPToken.sol\";\nimport \"../../userInterfaces/IVPContractEvents.sol\";\nimport \"./IICleanable.sol\";\n\ninterface IIVPContract is IICleanable, IVPContractEvents {\n    /**\n     * Update vote powers when tokens are transferred.\n     * Also update delegated vote powers for percentage delegation\n     * and check for enough funds for explicit delegations.\n     **/\n    function updateAtTokenTransfer(\n        address _from, \n        address _to, \n        uint256 _fromBalance,\n        uint256 _toBalance,\n        uint256 _amount\n    ) external;\n\n    /**\n     * @notice Delegate `_bips` percentage of voting power to `_to` from `_from`\n     * @param _from The address of the delegator\n     * @param _to The address of the recipient\n     * @param _balance The delegator's current balance\n     * @param _bips The percentage of voting power to be delegated expressed in basis points (1/100 of one percent).\n     *   Not cummulative - every call resets the delegation value (and value of 0 revokes delegation).\n     **/\n    function delegate(\n        address _from, \n        address _to, \n        uint256 _balance, \n        uint256 _bips\n    ) external;\n    \n    /**\n     * @notice Explicitly delegate `_amount` of voting power to `_to` from `msg.sender`.\n     * @param _from The address of the delegator\n     * @param _to The address of the recipient\n     * @param _balance The delegator's current balance\n     * @param _amount An explicit vote power amount to be delegated.\n     *   Not cummulative - every call resets the delegation value (and value of 0 undelegates `to`).\n     **/    \n    function delegateExplicit(\n        address _from, \n        address _to, \n        uint256 _balance, \n        uint _amount\n    ) external;    \n\n    /**\n     * @notice Revoke all delegation from sender to `_who` at given block. \n     *    Only affects the reads via `votePowerOfAtCached()` in the block `_blockNumber`.\n     *    Block `_blockNumber` must be in the past. \n     *    This method should be used only to prevent rogue delegate voting in the current voting block.\n     *    To stop delegating use delegate/delegateExplicit with value of 0 or undelegateAll/undelegateAllExplicit.\n     * @param _from The address of the delegator\n     * @param _who Address of the delegatee\n     * @param _balance The delegator's current balance\n     * @param _blockNumber The block number at which to revoke delegation.\n     **/\n    function revokeDelegationAt(\n        address _from, \n        address _who, \n        uint256 _balance,\n        uint _blockNumber\n    ) external;\n    \n        /**\n     * @notice Undelegate all voting power for delegates of `msg.sender`\n     *    Can only be used with percentage delegation.\n     *    Does not reset delegation mode back to NOTSET.\n     * @param _from The address of the delegator\n     **/\n    function undelegateAll(\n        address _from,\n        uint256 _balance\n    ) external;\n    \n    /**\n     * @notice Undelegate all explicit vote power by amount delegates for `msg.sender`.\n     *    Can only be used with explicit delegation.\n     *    Does not reset delegation mode back to NOTSET.\n     * @param _from The address of the delegator\n     * @param _delegateAddresses Explicit delegation does not store delegatees' addresses, \n     *   so the caller must supply them.\n     * @return The amount still delegated (in case the list of delegates was incomplete).\n     */\n    function undelegateAllExplicit(\n        address _from, \n        address[] memory _delegateAddresses\n    ) external returns (uint256);\n    \n    /**\n    * @notice Get the vote power of `_who` at block `_blockNumber`\n    *   Reads/updates cache and upholds revocations.\n    * @param _who The address to get voting power.\n    * @param _blockNumber The block number at which to fetch.\n    * @return Vote power of `_who` at `_blockNumber`.\n    */\n    function votePowerOfAtCached(address _who, uint256 _blockNumber) external returns(uint256);\n    \n    /**\n     * @notice Get the current vote power of `_who`.\n     * @param _who The address to get voting power.\n     * @return Current vote power of `_who`.\n     */\n    function votePowerOf(address _who) external view returns(uint256);\n    \n    /**\n    * @notice Get the vote power of `_who` at block `_blockNumber`\n    * @param _who The address to get voting power.\n    * @param _blockNumber The block number at which to fetch.\n    * @return Vote power of `_who` at `_blockNumber`.\n    */\n    function votePowerOfAt(address _who, uint256 _blockNumber) external view returns(uint256);\n\n    /**\n     * Return vote powers for several addresses in a batch.\n     * @param _owners The list of addresses to fetch vote power of.\n     * @param _blockNumber The block number at which to fetch.\n     * @return A list of vote powers.\n     */    \n    function batchVotePowerOfAt(\n        address[] memory _owners, \n        uint256 _blockNumber\n    )\n        external view returns(uint256[] memory);\n\n    /**\n    * @notice Get current delegated vote power `_from` delegator delegated `_to` delegatee.\n    * @param _from Address of delegator\n    * @param _to Address of delegatee\n    * @param _balance The delegator's current balance\n    * @return The delegated vote power.\n    */\n    function votePowerFromTo(\n        address _from, \n        address _to, \n        uint256 _balance\n    ) external view returns(uint256);\n    \n    /**\n    * @notice Get delegated the vote power `_from` delegator delegated `_to` delegatee at `_blockNumber`.\n    * @param _from Address of delegator\n    * @param _to Address of delegatee\n    * @param _balance The delegator's current balance\n    * @param _blockNumber The block number at which to fetch.\n    * @return The delegated vote power.\n    */\n    function votePowerFromToAt(\n        address _from, \n        address _to, \n        uint256 _balance,\n        uint _blockNumber\n    ) external view returns(uint256);\n\n    /**\n     * @notice Compute the current undelegated vote power of `_owner`\n     * @param _owner The address to get undelegated voting power.\n     * @param _balance Owner's current balance\n     * @return The unallocated vote power of `_owner`\n     */\n    function undelegatedVotePowerOf(\n        address _owner,\n        uint256 _balance\n    ) external view returns(uint256);\n\n    /**\n     * @notice Get the undelegated vote power of `_owner` at given block.\n     * @param _owner The address to get undelegated voting power.\n     * @param _blockNumber The block number at which to fetch.\n     * @return The undelegated vote power of `_owner` (= owner's own balance minus all delegations from owner)\n     */\n    function undelegatedVotePowerOfAt(\n        address _owner, \n        uint256 _balance,\n        uint256 _blockNumber\n    ) external view returns(uint256);\n\n    /**\n     * @notice Get the delegation mode for '_who'. This mode determines whether vote power is\n     *  allocated by percentage or by explicit value.\n     * @param _who The address to get delegation mode.\n     * @return Delegation mode (NOTSET=0, PERCENTAGE=1, AMOUNT=2))\n     */\n    function delegationModeOf(address _who) external view returns (uint256);\n    \n    /**\n    * @notice Get the vote power delegation `_delegateAddresses` \n    *  and `pcts` of an `_owner`. Returned in two separate positional arrays.\n    * @param _owner The address to get delegations.\n    * @return _delegateAddresses Positional array of delegation addresses.\n    * @return _bips Positional array of delegation percents specified in basis points (1/100 or 1 percent)\n    * @return _count The number of delegates.\n    * @return _delegationMode The mode of the delegation (NOTSET=0, PERCENTAGE=1, AMOUNT=2).\n    */\n    function delegatesOf(\n        address _owner\n    )\n        external view \n        returns (\n            address[] memory _delegateAddresses, \n            uint256[] memory _bips,\n            uint256 _count,\n            uint256 _delegationMode\n        );\n\n    /**\n    * @notice Get the vote power delegation `delegationAddresses` \n    *  and `pcts` of an `_owner`. Returned in two separate positional arrays.\n    * @param _owner The address to get delegations.\n    * @param _blockNumber The block for which we want to know the delegations.\n    * @return _delegateAddresses Positional array of delegation addresses.\n    * @return _bips Positional array of delegation percents specified in basis points (1/100 or 1 percent)\n    * @return _count The number of delegates.\n    * @return _delegationMode The mode of the delegation (NOTSET=0, PERCENTAGE=1, AMOUNT=2).\n    */\n    function delegatesOfAt(\n        address _owner,\n        uint256 _blockNumber\n    )\n        external view \n        returns (\n            address[] memory _delegateAddresses, \n            uint256[] memory _bips,\n            uint256 _count,\n            uint256 _delegationMode\n        );\n\n    /**\n     * The VPToken (or some other contract) that owns this VPContract.\n     * All state changing methods may be called only from this address.\n     * This is because original msg.sender is sent in `_from` parameter\n     * and we must be sure that it cannot be faked by directly calling VPContract.\n     * Owner token is also used in case of replacement to recover vote powers from balances.\n     */\n    function ownerToken() external view returns (IVPToken);\n    \n    /**\n     * Return true if this IIVPContract is configured to be used as a replacement for other contract.\n     * It means that vote powers are not necessarily correct at the initialization, therefore\n     * every method that reads vote power must check whether it is initialized for that address and block.\n     */\n    function isReplacement() external view returns (bool);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston/util-contracts/token/token/interface/IIVPToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\nimport \"../../userInterfaces/IVPToken.sol\";\nimport \"../../../../governance/userInterfaces/IGovernanceVotePower.sol\";\nimport \"./IIVPContract.sol\";\nimport \"./IIGovernanceVotePower.sol\";\nimport \"./IICleanable.sol\";\n\ninterface IIVPToken is IVPToken, IICleanable {\n    /**\n     * Sets new governance vote power contract that allows token owners to participate in governance voting\n     * and delegate governance vote power. \n     */\n    function setGovernanceVotePower(IIGovernanceVotePower _governanceVotePower) external;\n    \n    /**\n    * @notice Get the total vote power at block `_blockNumber` using cache.\n    *   It tries to read the cached value and if not found, reads the actual value and stores it in cache.\n    *   Can only be used if `_blockNumber` is in the past, otherwise reverts.    \n    * @param _blockNumber The block number at which to fetch.\n    * @return The total vote power at the block (sum of all accounts' vote powers).\n    */\n    function totalVotePowerAtCached(uint256 _blockNumber) external returns(uint256);\n    \n    /**\n    * @notice Get the vote power of `_owner` at block `_blockNumber` using cache.\n    *   It tries to read the cached value and if not found, reads the actual value and stores it in cache.\n    *   Can only be used if _blockNumber is in the past, otherwise reverts.    \n    * @param _owner The address to get voting power.\n    * @param _blockNumber The block number at which to fetch.\n    * @return Vote power of `_owner` at `_blockNumber`.\n    */\n    function votePowerOfAtCached(address _owner, uint256 _blockNumber) external returns(uint256);\n\n    /**\n     * Return vote powers for several addresses in a batch.\n     * @param _owners The list of addresses to fetch vote power of.\n     * @param _blockNumber The block number at which to fetch.\n     * @return A list of vote powers.\n     */    \n    function batchVotePowerOfAt(\n        address[] memory _owners, \n        uint256 _blockNumber\n    ) external view returns(uint256[] memory);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston/util-contracts/token/userInterfaces/IVPContractEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\ninterface IVPContractEvents {\n    /**\n     * Event triggered when an account delegates or undelegates another account. \n     * Definition: `votePowerFromTo(from, to)` is `changed` from `priorVotePower` to `newVotePower`.\n     * For undelegation, `newVotePower` is 0.\n     *\n     * Note: the event is always emitted from VPToken's `writeVotePowerContract`.\n     */\n    event Delegate(address indexed from, address indexed to, uint256 priorVotePower, uint256 newVotePower);\n    \n    /**\n     * Event triggered only when account `delegator` revokes delegation to `delegatee`\n     * for a single block in the past (typically the current vote block).\n     *\n     * Note: the event is always emitted from VPToken's `writeVotePowerContract` and/or `readVotePowerContract`.\n     */\n    event Revoke(address indexed delegator, address indexed delegatee, uint256 votePower, uint256 blockNumber);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston/util-contracts/token/userInterfaces/IVPToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../../governance/userInterfaces/IGovernanceVotePower.sol\";\nimport \"./IVPContractEvents.sol\";\n\ninterface IVPToken is IERC20 {\n    /**\n     * @notice Delegate by percentage `_bips` of voting power to `_to` from `msg.sender`.\n     * @param _to The address of the recipient\n     * @param _bips The percentage of voting power to be delegated expressed in basis points (1/100 of one percent).\n     *   Not cummulative - every call resets the delegation value (and value of 0 undelegates `to`).\n     **/\n    function delegate(address _to, uint256 _bips) external;\n    \n    /**\n     * @notice Explicitly delegate `_amount` of voting power to `_to` from `msg.sender`.\n     * @param _to The address of the recipient\n     * @param _amount An explicit vote power amount to be delegated.\n     *   Not cummulative - every call resets the delegation value (and value of 0 undelegates `to`).\n     **/    \n    function delegateExplicit(address _to, uint _amount) external;\n\n    /**\n    * @notice Revoke all delegation from sender to `_who` at given block. \n    *    Only affects the reads via `votePowerOfAtCached()` in the block `_blockNumber`.\n    *    Block `_blockNumber` must be in the past. \n    *    This method should be used only to prevent rogue delegate voting in the current voting block.\n    *    To stop delegating use delegate/delegateExplicit with value of 0 or undelegateAll/undelegateAllExplicit.\n    * @param _who Address of the delegatee\n    * @param _blockNumber The block number at which to revoke delegation.\n    */\n    function revokeDelegationAt(address _who, uint _blockNumber) external;\n    \n    /**\n     * @notice Undelegate all voting power for delegates of `msg.sender`\n     *    Can only be used with percentage delegation.\n     *    Does not reset delegation mode back to NOTSET.\n     **/\n    function undelegateAll() external;\n    \n    /**\n     * @notice Undelegate all explicit vote power by amount delegates for `msg.sender`.\n     *    Can only be used with explicit delegation.\n     *    Does not reset delegation mode back to NOTSET.\n     * @param _delegateAddresses Explicit delegation does not store delegatees' addresses, \n     *   so the caller must supply them.\n     * @return The amount still delegated (in case the list of delegates was incomplete).\n     */\n    function undelegateAllExplicit(address[] memory _delegateAddresses) external returns (uint256);\n\n\n    /**\n     * @dev Should be compatible with ERC20 method\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Should be compatible with ERC20 method\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Should be compatible with ERC20 method\n     */\n    function decimals() external view returns (uint8);\n    \n\n    /**\n     * @notice Total amount of tokens at a specific `_blockNumber`.\n     * @param _blockNumber The block number when the totalSupply is queried\n     * @return The total amount of tokens at `_blockNumber`\n     **/\n    function totalSupplyAt(uint _blockNumber) external view returns(uint256);\n\n    /**\n     * @dev Queries the token balance of `_owner` at a specific `_blockNumber`.\n     * @param _owner The address from which the balance will be retrieved.\n     * @param _blockNumber The block number when the balance is queried.\n     * @return The balance at `_blockNumber`.\n     **/\n    function balanceOfAt(address _owner, uint _blockNumber) external view returns (uint256);\n\n    \n    /**\n     * @notice Get the current total vote power.\n     * @return The current total vote power (sum of all accounts' vote powers).\n     */\n    function totalVotePower() external view returns(uint256);\n    \n    /**\n    * @notice Get the total vote power at block `_blockNumber`\n    * @param _blockNumber The block number at which to fetch.\n    * @return The total vote power at the block  (sum of all accounts' vote powers).\n    */\n    function totalVotePowerAt(uint _blockNumber) external view returns(uint256);\n\n    /**\n     * @notice Get the current vote power of `_owner`.\n     * @param _owner The address to get voting power.\n     * @return Current vote power of `_owner`.\n     */\n    function votePowerOf(address _owner) external view returns(uint256);\n    \n    /**\n    * @notice Get the vote power of `_owner` at block `_blockNumber`\n    * @param _owner The address to get voting power.\n    * @param _blockNumber The block number at which to fetch.\n    * @return Vote power of `_owner` at `_blockNumber`.\n    */\n    function votePowerOfAt(address _owner, uint256 _blockNumber) external view returns(uint256);\n\n\n    /**\n     * @notice Get the delegation mode for '_who'. This mode determines whether vote power is\n     *  allocated by percentage or by explicit value. Once the delegation mode is set, \n     *  it never changes, even if all delegations are removed.\n     * @param _who The address to get delegation mode.\n     * @return delegation mode: 0 = NOTSET, 1 = PERCENTAGE, 2 = AMOUNT (i.e. explicit)\n     */\n    function delegationModeOf(address _who) external view returns(uint256);\n        \n    /**\n    * @notice Get current delegated vote power `_from` delegator delegated `_to` delegatee.\n    * @param _from Address of delegator\n    * @param _to Address of delegatee\n    * @return The delegated vote power.\n    */\n    function votePowerFromTo(address _from, address _to) external view returns(uint256);\n    \n    /**\n    * @notice Get delegated the vote power `_from` delegator delegated `_to` delegatee at `_blockNumber`.\n    * @param _from Address of delegator\n    * @param _to Address of delegatee\n    * @param _blockNumber The block number at which to fetch.\n    * @return The delegated vote power.\n    */\n    function votePowerFromToAt(address _from, address _to, uint _blockNumber) external view returns(uint256);\n    \n    /**\n     * @notice Compute the current undelegated vote power of `_owner`\n     * @param _owner The address to get undelegated voting power.\n     * @return The unallocated vote power of `_owner`\n     */\n    function undelegatedVotePowerOf(address _owner) external view returns(uint256);\n    \n    /**\n     * @notice Get the undelegated vote power of `_owner` at given block.\n     * @param _owner The address to get undelegated voting power.\n     * @param _blockNumber The block number at which to fetch.\n     * @return The undelegated vote power of `_owner` (= owner's own balance minus all delegations from owner)\n     */\n    function undelegatedVotePowerOfAt(address _owner, uint256 _blockNumber) external view returns(uint256);\n    \n    /**\n    * @notice Get the vote power delegation `delegationAddresses` \n    *  and `_bips` of `_who`. Returned in two separate positional arrays.\n    * @param _who The address to get delegations.\n    * @return _delegateAddresses Positional array of delegation addresses.\n    * @return _bips Positional array of delegation percents specified in basis points (1/100 or 1 percent)\n    * @return _count The number of delegates.\n    * @return _delegationMode The mode of the delegation (NOTSET=0, PERCENTAGE=1, AMOUNT=2).\n    */\n    function delegatesOf(address _who)\n        external view \n        returns (\n            address[] memory _delegateAddresses,\n            uint256[] memory _bips,\n            uint256 _count, \n            uint256 _delegationMode\n        );\n        \n    /**\n    * @notice Get the vote power delegation `delegationAddresses` \n    *  and `pcts` of `_who`. Returned in two separate positional arrays.\n    * @param _who The address to get delegations.\n    * @param _blockNumber The block for which we want to know the delegations.\n    * @return _delegateAddresses Positional array of delegation addresses.\n    * @return _bips Positional array of delegation percents specified in basis points (1/100 or 1 percent)\n    * @return _count The number of delegates.\n    * @return _delegationMode The mode of the delegation (NOTSET=0, PERCENTAGE=1, AMOUNT=2).\n    */\n    function delegatesOfAt(address _who, uint256 _blockNumber)\n        external view \n        returns (\n            address[] memory _delegateAddresses, \n            uint256[] memory _bips, \n            uint256 _count, \n            uint256 _delegationMode\n        );\n\n    /**\n     * Returns VPContract used for readonly operations (view methods).\n     * The only non-view method that might be called on it is `revokeDelegationAt`.\n     *\n     * @notice `readVotePowerContract` is almost always equal to `writeVotePowerContract`\n     * except during upgrade from one VPContract to a new version (which should happen\n     * rarely or never and will be anounced before).\n     *\n     * @notice You shouldn't call any methods on VPContract directly, all are exposed\n     * via VPToken (and state changing methods are forbidden from direct calls). \n     * This is the reason why this method returns `IVPContractEvents` - it should only be used\n     * for listening to events (`Revoke` only).\n     */\n    function readVotePowerContract() external view returns (IVPContractEvents);\n\n    /**\n     * Returns VPContract used for state changing operations (non-view methods).\n     * The only non-view method that might be called on it is `revokeDelegationAt`.\n     *\n     * @notice `writeVotePowerContract` is almost always equal to `readVotePowerContract`\n     * except during upgrade from one VPContract to a new version (which should happen\n     * rarely or never and will be anounced before). In the case of upgrade,\n     * `writeVotePowerContract` will be replaced first to establish delegations, and\n     * after some perio (e.g. after a reward epoch ends) `readVotePowerContract` will be set equal to it.\n     *\n     * @notice You shouldn't call any methods on VPContract directly, all are exposed\n     * via VPToken (and state changing methods are forbidden from direct calls). \n     * This is the reason why this method returns `IVPContractEvents` - it should only be used\n     * for listening to events (`Delegate` and `Revoke` only).\n     */\n    function writeVotePowerContract() external view returns (IVPContractEvents);\n    \n    /**\n     * When set, allows token owners to participate in governance voting\n     * and delegate governance vote power.\n     */\n    function governanceVotePower() external view returns (IGovernanceVotePower);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston/util-contracts/token/userInterfaces/IWNat.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\ninterface IWNat {\n    /**\n     * @notice Deposit native token and mint WNAT ERC20.\n     */\n    function deposit() external payable;\n\n    /**\n     * @notice Withdraw native token and burn WNAT ERC20.\n     * @param _amount The amount to withdraw.\n     */\n    function withdraw(uint256 _amount) external;\n    \n    /**\n     * @notice Deposit native token from msg.sender and mint WNAT ERC20.\n     * @param _recipient An address to receive minted WNAT.\n     */\n    function depositTo(address _recipient) external payable;\n    \n    /**\n     * @notice Withdraw WNAT from an owner and send NAT to msg.sender given an allowance.\n     * @param _owner An address spending the native tokens.\n     * @param _amount The amount to spend.\n     *\n     * Requirements:\n     *\n     * - `_owner` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_owners`'s tokens of at least\n     * `_amount`.\n     */\n    function withdrawFrom(address _owner, uint256 _amount) external;\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/coston/util-contracts/userInterfaces/IFlareContractRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\npragma abicoder v2;\n\ninterface IFlareContractRegistry {\n    /**\n     * @notice Returns contract address for the given name - might be address(0)\n     * @param _name             name of the contract\n     */\n    function getContractAddressByName(string calldata _name) external view returns(address);\n\n    /**\n     * @notice Returns contract address for the given name hash - might be address(0)\n     * @param _nameHash         hash of the contract name (keccak256(abi.encode(name))\n     */\n    function getContractAddressByHash(bytes32 _nameHash) external view returns(address);\n\n    /**\n     * @notice Returns contract addresses for the given names - might be address(0)\n     * @param _names            names of the contracts\n     */\n    function getContractAddressesByName(string[] calldata _names) external view returns(address[] memory);\n\n    /**\n     * @notice Returns contract addresses for the given name hashes - might be address(0)\n     * @param _nameHashes       hashes of the contract names (keccak256(abi.encode(name))\n     */\n    function getContractAddressesByHash(bytes32[] calldata _nameHashes) external view returns(address[] memory);\n\n    /**\n     * @notice Returns all contract names and corresponding addresses\n     */\n    function getAllContracts() external view returns(string[] memory _names, address[] memory _addresses);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/flare/ftso/ftso/interface/IIFtso.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\nimport \"../../genesis/interface/IFtsoGenesis.sol\";\nimport \"../../userInterfaces/IFtso.sol\";\nimport \"../../../util-contracts/token/token/interface/IIVPToken.sol\";\n\n\ninterface IIFtso is IFtso, IFtsoGenesis {\n\n    /// function finalizePriceReveal\n    /// called by reward manager only on correct timing.\n    /// if price reveal period for epoch x ended. finalize.\n    /// iterate list of price submissions\n    /// find weighted median\n    /// find adjucant 50% of price submissions.\n    /// Allocate reward for any price submission which is same as a \"winning\" submission\n    function finalizePriceEpoch(uint256 _epochId, bool _returnRewardData) external\n        returns(\n            address[] memory _eligibleAddresses,\n            uint256[] memory _natWeights,\n            uint256 _totalNatWeight\n        );\n\n    function fallbackFinalizePriceEpoch(uint256 _epochId) external;\n\n    function forceFinalizePriceEpoch(uint256 _epochId) external;\n\n    // activateFtso will be called by ftso manager once ftso is added \n    // before this is done, FTSO can't run\n    function activateFtso(\n        uint256 _firstEpochStartTs,\n        uint256 _submitPeriodSeconds,\n        uint256 _revealPeriodSeconds\n    ) external;\n\n    function deactivateFtso() external;\n\n    // update initial price and timestamp - only if not active\n    function updateInitialPrice(uint256 _initialPriceUSD, uint256 _initialPriceTimestamp) external;\n\n    function configureEpochs(\n        uint256 _maxVotePowerNatThresholdFraction,\n        uint256 _maxVotePowerAssetThresholdFraction,\n        uint256 _lowAssetUSDThreshold,\n        uint256 _highAssetUSDThreshold,\n        uint256 _highAssetTurnoutThresholdBIPS,\n        uint256 _lowNatTurnoutThresholdBIPS,\n        uint256 _elasticBandRewardBIPS,\n        uint256 _elasticBandWidthPPM,\n        address[] memory _trustedAddresses\n    ) external;\n\n    function setAsset(IIVPToken _asset) external;\n\n    function setAssetFtsos(IIFtso[] memory _assetFtsos) external;\n\n    // current vote power block will update per reward epoch. \n    // the FTSO doesn't have notion of reward epochs.\n    // reward manager only can set this data. \n    function setVotePowerBlock(uint256 _blockNumber) external;\n\n    function initializeCurrentEpochStateForReveal(uint256 _circulatingSupplyNat, bool _fallbackMode) external;\n  \n    /**\n     * @notice Returns ftso manager address\n     */\n    function ftsoManager() external view returns (address);\n\n    /**\n     * @notice Returns the FTSO asset\n     * @dev Asset is null in case of multi-asset FTSO\n     */\n    function getAsset() external view returns (IIVPToken);\n\n    /**\n     * @notice Returns the Asset FTSOs\n     * @dev AssetFtsos is not null only in case of multi-asset FTSO\n     */\n    function getAssetFtsos() external view returns (IIFtso[] memory);\n\n    /**\n     * @notice Returns current configuration of epoch state\n     * @return _maxVotePowerNatThresholdFraction        High threshold for native token vote power per voter\n     * @return _maxVotePowerAssetThresholdFraction      High threshold for asset vote power per voter\n     * @return _lowAssetUSDThreshold            Threshold for low asset vote power\n     * @return _highAssetUSDThreshold           Threshold for high asset vote power\n     * @return _highAssetTurnoutThresholdBIPS   Threshold for high asset turnout\n     * @return _lowNatTurnoutThresholdBIPS      Threshold for low nat turnout\n     * @return _elasticBandRewardBIPS           Hybrid reward band, where _elasticBandRewardBIPS goes to the \n        elastic band (prices within _elasticBandWidthPPM of the median) \n        and 10000 - elasticBandRewardBIPS to the IQR \n     * @return _elasticBandWidthPPM             Prices within _elasticBandWidthPPM of median are rewarded\n     * @return _trustedAddresses                Trusted addresses - use their prices if low nat turnout is not achieved\n     */\n    function epochsConfiguration() external view \n        returns (\n            uint256 _maxVotePowerNatThresholdFraction,\n            uint256 _maxVotePowerAssetThresholdFraction,\n            uint256 _lowAssetUSDThreshold,\n            uint256 _highAssetUSDThreshold,\n            uint256 _highAssetTurnoutThresholdBIPS,\n            uint256 _lowNatTurnoutThresholdBIPS,\n            uint256 _elasticBandRewardBIPS,\n            uint256 _elasticBandWidthPPM,\n            address[] memory _trustedAddresses\n        );\n\n    /**\n     * @notice Returns parameters necessary for approximately replicating vote weighting.\n     * @return _assets                  the list of Assets that are accounted in vote\n     * @return _assetMultipliers        weight of each asset in (multiasset) ftso, mutiplied by TERA\n     * @return _totalVotePowerNat       total native token vote power at block\n     * @return _totalVotePowerAsset     total combined asset vote power at block\n     * @return _assetWeightRatio        ratio of combined asset vp vs. native token vp (in BIPS)\n     * @return _votePowerBlock          vote powewr block for given epoch\n     */\n    function getVoteWeightingParameters() external view \n        returns (\n            IIVPToken[] memory _assets,\n            uint256[] memory _assetMultipliers,\n            uint256 _totalVotePowerNat,\n            uint256 _totalVotePowerAsset,\n            uint256 _assetWeightRatio,\n            uint256 _votePowerBlock\n        );\n\n    function wNat() external view returns (IIVPToken);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/flare/ftso/genesis/interface/IFtsoGenesis.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\n\ninterface IFtsoGenesis {\n\n    /**\n     * @notice Reveals submitted price during epoch reveal period - only price submitter\n     * @param _voter                Voter address\n     * @param _epochId              Id of the epoch in which the price hash was submitted\n     * @param _price                Submitted price in USD\n     * @notice The hash of _price and _random must be equal to the submitted hash\n     * @notice Emits PriceRevealed event\n     */\n    function revealPriceSubmitter(\n        address _voter,\n        uint256 _epochId,\n        uint256 _price,\n        uint256 _wNatVP\n    ) external;\n\n    /**\n     * @notice Get (and cache) wNat vote power for specified voter and given epoch id\n     * @param _voter                Voter address\n     * @param _epochId              Id of the epoch in which the price hash was submitted\n     * @return wNat vote power\n     */\n    function wNatVotePowerCached(address _voter, uint256 _epochId) external returns (uint256);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/flare/ftso/genesis/interface/IFtsoRegistryGenesis.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\nimport \"./IFtsoGenesis.sol\";\n\n\ninterface IFtsoRegistryGenesis {\n\n    function getFtsos(uint256[] memory _indices) external view returns(IFtsoGenesis[] memory _ftsos);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/flare/ftso/userInterfaces/IFtso.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\ninterface IFtso {\n    enum PriceFinalizationType {\n        // initial state\n        NOT_FINALIZED,\n        // median calculation used to find price\n        WEIGHTED_MEDIAN,\n        // low turnout - price calculated from median of trusted addresses\n        TRUSTED_ADDRESSES,\n        // low turnout + no votes from trusted addresses - price copied from previous epoch\n        PREVIOUS_PRICE_COPIED,\n        // price calculated from median of trusted addresses - triggered due to an exception\n        TRUSTED_ADDRESSES_EXCEPTION,\n        // previous price copied - triggered due to an exception\n        PREVIOUS_PRICE_COPIED_EXCEPTION\n    }\n\n    event PriceRevealed(\n        address indexed voter, uint256 indexed epochId, uint256 price, uint256 timestamp,\n        uint256 votePowerNat, uint256 votePowerAsset\n    );\n\n    event PriceFinalized(\n        uint256 indexed epochId, uint256 price, bool rewardedFtso,\n        uint256 lowIQRRewardPrice, uint256 highIQRRewardPrice,\n        uint256 lowElasticBandRewardPrice, uint256 highElasticBandRewardPrice, \n        PriceFinalizationType finalizationType, uint256 timestamp\n    );\n\n    event PriceEpochInitializedOnFtso(\n        uint256 indexed epochId, uint256 endTime, uint256 timestamp\n    );\n\n    event LowTurnout(\n        uint256 indexed epochId,\n        uint256 natTurnout,\n        uint256 lowNatTurnoutThresholdBIPS,\n        uint256 timestamp\n    );\n\n    /**\n     * @notice Returns if FTSO is active\n     */\n    function active() external view returns (bool);\n\n    /**\n     * @notice Returns the FTSO symbol\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @notice Returns current epoch id\n     */\n    function getCurrentEpochId() external view returns (uint256);\n\n    /**\n     * @notice Returns id of the epoch which was opened for price submission at the specified timestamp\n     * @param _timestamp            Timestamp as seconds from unix epoch\n     */\n    function getEpochId(uint256 _timestamp) external view returns (uint256);\n    \n    /**\n     * @notice Returns random number of the specified epoch\n     * @param _epochId              Id of the epoch\n     */\n    function getRandom(uint256 _epochId) external view returns (uint256);\n\n    /**\n     * @notice Returns asset price consented in specific epoch\n     * @param _epochId              Id of the epoch\n     * @return Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\n     */\n    function getEpochPrice(uint256 _epochId) external view returns (uint256);\n\n    /**\n     * @notice Returns current epoch data\n     * @return _epochId                 Current epoch id\n     * @return _epochSubmitEndTime      End time of the current epoch price submission as seconds from unix epoch\n     * @return _epochRevealEndTime      End time of the current epoch price reveal as seconds from unix epoch\n     * @return _votePowerBlock          Vote power block for the current epoch\n     * @return _fallbackMode            Current epoch in fallback mode - only votes from trusted addresses will be used\n     * @dev half-closed intervals - end time not included\n     */\n    function getPriceEpochData() external view returns (\n        uint256 _epochId,\n        uint256 _epochSubmitEndTime,\n        uint256 _epochRevealEndTime,\n        uint256 _votePowerBlock,\n        bool _fallbackMode\n    );\n\n    /**\n     * @notice Returns current epoch data\n     * @return _firstEpochStartTs           First epoch start timestamp\n     * @return _submitPeriodSeconds         Submit period in seconds\n     * @return _revealPeriodSeconds         Reveal period in seconds\n     */\n    function getPriceEpochConfiguration() external view returns (\n        uint256 _firstEpochStartTs,\n        uint256 _submitPeriodSeconds,\n        uint256 _revealPeriodSeconds\n    );\n    \n    /**\n     * @notice Returns asset price submitted by voter in specific epoch\n     * @param _epochId              Id of the epoch\n     * @param _voter                Address of the voter\n     * @return Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\n     */\n    function getEpochPriceForVoter(uint256 _epochId, address _voter) external view returns (uint256);\n\n    /**\n     * @notice Returns current asset price\n     * @return _price               Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\n     * @return _timestamp           Time when price was updated for the last time\n     */\n    function getCurrentPrice() external view returns (uint256 _price, uint256 _timestamp);\n\n    /**\n     * @notice Returns current asset price and number of decimals\n     * @return _price                   Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\n     * @return _timestamp               Time when price was updated for the last time\n     * @return _assetPriceUsdDecimals   Number of decimals used for USD price\n     */\n    function getCurrentPriceWithDecimals() external view returns (\n        uint256 _price,\n        uint256 _timestamp,\n        uint256 _assetPriceUsdDecimals\n    );\n    \n    /**\n     * @notice Returns current asset price calculated from trusted providers\n     * @return _price               Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\n     * @return _timestamp           Time when price was updated for the last time\n     */\n    function getCurrentPriceFromTrustedProviders() external view returns (uint256 _price, uint256 _timestamp);\n\n    /**\n     * @notice Returns current asset price calculated from trusted providers and number of decimals\n     * @return _price                   Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\n     * @return _timestamp               Time when price was updated for the last time\n     * @return _assetPriceUsdDecimals   Number of decimals used for USD price\n     */\n    function getCurrentPriceWithDecimalsFromTrustedProviders() external view returns (\n        uint256 _price,\n        uint256 _timestamp,\n        uint256 _assetPriceUsdDecimals\n    );\n\n    /**\n     * @notice Returns current asset price details\n     * @return _price                                   Price in USD multiplied by ASSET_PRICE_USD_DECIMALS\n     * @return _priceTimestamp                          Time when price was updated for the last time\n     * @return _priceFinalizationType                   Finalization type when price was updated for the last time\n     * @return _lastPriceEpochFinalizationTimestamp     Time when last price epoch was finalized\n     * @return _lastPriceEpochFinalizationType          Finalization type of last finalized price epoch\n     */\n    function getCurrentPriceDetails() external view returns (\n        uint256 _price,\n        uint256 _priceTimestamp,\n        PriceFinalizationType _priceFinalizationType,\n        uint256 _lastPriceEpochFinalizationTimestamp,\n        PriceFinalizationType _lastPriceEpochFinalizationType\n    );\n\n    /**\n     * @notice Returns current random number\n     */\n    function getCurrentRandom() external view returns (uint256);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/flare/ftso/userInterfaces/IFtsoRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\npragma abicoder v2;\n\nimport \"../ftso/interface/IIFtso.sol\";\nimport \"../genesis/interface/IFtsoRegistryGenesis.sol\";\n\ninterface IFtsoRegistry is IFtsoRegistryGenesis {\n\n    struct PriceInfo {\n        uint256 ftsoIndex;\n        uint256 price;\n        uint256 decimals;\n        uint256 timestamp;\n    }\n\n    function getFtso(uint256 _ftsoIndex) external view returns(IIFtso _activeFtsoAddress);\n    function getFtsoBySymbol(string memory _symbol) external view returns(IIFtso _activeFtsoAddress);\n    function getSupportedIndices() external view returns(uint256[] memory _supportedIndices);\n    function getSupportedSymbols() external view returns(string[] memory _supportedSymbols);\n    function getSupportedFtsos() external view returns(IIFtso[] memory _ftsos);\n    function getFtsoIndex(string memory _symbol) external view returns (uint256 _assetIndex);\n    function getFtsoSymbol(uint256 _ftsoIndex) external view returns (string memory _symbol);\n    function getCurrentPrice(uint256 _ftsoIndex) external view returns(uint256 _price, uint256 _timestamp);\n    function getCurrentPrice(string memory _symbol) external view returns(uint256 _price, uint256 _timestamp);\n    function getCurrentPriceWithDecimals(uint256 _assetIndex) external view\n        returns(uint256 _price, uint256 _timestamp, uint256 _assetPriceUsdDecimals);\n    function getCurrentPriceWithDecimals(string memory _symbol) external view\n        returns(uint256 _price, uint256 _timestamp, uint256 _assetPriceUsdDecimals);\n\n    function getAllCurrentPrices() external view returns (PriceInfo[] memory);\n    function getCurrentPricesByIndices(uint256[] memory _indices) external view returns (PriceInfo[] memory);\n    function getCurrentPricesBySymbols(string[] memory _symbols) external view returns (PriceInfo[] memory);\n\n    function getSupportedIndicesAndFtsos() external view \n        returns(uint256[] memory _supportedIndices, IIFtso[] memory _ftsos);\n\n    function getSupportedSymbolsAndFtsos() external view \n        returns(string[] memory _supportedSymbols, IIFtso[] memory _ftsos);\n\n    function getSupportedIndicesAndSymbols() external view \n        returns(uint256[] memory _supportedIndices, string[] memory _supportedSymbols);\n\n    function getSupportedIndicesSymbolsAndFtsos() external view \n        returns(uint256[] memory _supportedIndices, string[] memory _supportedSymbols, IIFtso[] memory _ftsos);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/flare/governance/userInterfaces/IGovernanceVotePower.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\n/**\n * Interface for contracts delegating their governance vote power.\n */\ninterface IGovernanceVotePower {\n    /**\n     * Delegates all governance vote power of `msg.sender` to address `_to`.\n     * @param _to The address of the recipient.\n     */\n    function delegate(address _to) external;\n\n    /**\n     * Undelegates all governance vote power of `msg.sender`.\n     */\n    function undelegate() external;\n\n    /**\n     * Gets the governance vote power of an address at a given block number, including\n     * all delegations made to it.\n     * @param _who The address being queried.\n     * @param _blockNumber The block number at which to fetch the vote power.\n     * @return Governance vote power of `_who` at `_blockNumber`.\n     */\n    function votePowerOfAt(address _who, uint256 _blockNumber) external view returns(uint256);\n\n    /**\n     * Gets the governance vote power of an address at the latest block, including\n     * all delegations made to it.\n     * @param _who The address being queried.\n     * @return Governance vote power of `account` at the lastest block.\n     */\n    function getVotes(address _who) external view returns (uint256);\n\n    /**\n     * Gets the address an account is delegating its governance vote power to, at a given block number.\n     * @param _who The address being queried.\n     * @param _blockNumber The block number at which to fetch the address.\n     * @return Address where `_who` was delegating its governance vote power at block `_blockNumber`.\n     */\n    function getDelegateOfAt(address _who, uint256 _blockNumber) external view returns (address);\n\n    /**\n     * Gets the address an account is delegating its governance vote power to, at the latest block number.\n     * @param _who The address being queried.\n     * @return Address where `_who` is currently delegating its governance vote power.\n     */\n    function getDelegateOfAtNow(address _who) external view returns (address);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/flare/util-contracts/infrastructure/userInterfaces/IPChainStakeMirror.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\npragma abicoder v2;\n\nimport \"./IPChainVotePower.sol\";\nimport \"./IPChainStakeMirrorVerifier.sol\";\n\n\n/**\n * Interface for the `PChainStakeMirror` contract.\n */\ninterface IPChainStakeMirror is IPChainVotePower {\n\n    /**\n     * Event emitted when max updates per block is set.\n     * @param maxUpdatesPerBlock new number of max updated per block\n     */\n    event MaxUpdatesPerBlockSet(uint256 maxUpdatesPerBlock);\n\n    /**\n     * Event emitted when the stake is confirmed.\n     * @param owner The address who opened the stake.\n     * @param nodeId Node id to which the stake was added.\n     * @param txHash Unique tx hash - keccak256(abi.encode(PChainStake.txId, PChainStake.inputAddress));\n     * @param amountWei Stake amount (in wei).\n     * @param pChainTxId P-chain transaction id.\n     */\n    event StakeConfirmed(\n        address indexed owner,\n        bytes20 indexed nodeId,\n        bytes32 indexed txHash,\n        uint256 amountWei,\n        bytes32 pChainTxId\n    );\n\n    /**\n     * Event emitted when the stake has ended.\n     * @param owner The address whose stake has ended.\n     * @param nodeId Node id from which the stake was removed.\n     * @param txHash Unique tx hash - keccak256(abi.encode(PChainStake.txId, PChainStake.inputAddress));\n     * @param amountWei Stake amount (in wei).\n     */\n    event StakeEnded(\n        address indexed owner,\n        bytes20 indexed nodeId,\n        bytes32 indexed txHash,\n        uint256 amountWei\n    );\n\n    /**\n     * Event emitted when the stake was revoked.\n     * @param owner The address whose stake has ended.\n     * @param nodeId Node id from which the stake was removed.\n     * @param txHash Unique tx hash - keccak256(abi.encode(PChainStake.txId, PChainStake.inputAddress));\n     * @param amountWei Stake amount (in wei).\n     */\n    event StakeRevoked(\n        address indexed owner,\n        bytes20 indexed nodeId,\n        bytes32 indexed txHash,\n        uint256 amountWei\n    );\n\n    /**\n     * Method for P-chain stake mirroring using `PChainStake` data and Merkle proof.\n     * @param _stakeData Information about P-chain stake.\n     * @param _merkleProof Merkle proof that should be used to prove the P-chain stake.\n     */\n    function mirrorStake(\n        IPChainStakeMirrorVerifier.PChainStake calldata _stakeData,\n        bytes32[] calldata _merkleProof\n    )\n        external;\n\n    /**\n     * Method for checking if active stake (stake start time <= block.timestamp < stake end time) was already mirrored.\n     * @param _txId P-chain stake transaction id.\n     * @param _inputAddress P-chain address that opened stake.\n     * @return True if stake is active and mirrored.\n     */\n    function isActiveStakeMirrored(bytes32 _txId, bytes20 _inputAddress) external view returns(bool);\n\n    /**\n     * Total amount of tokens at current block.\n     * @return The current total amount of tokens.\n     **/\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * Total amount of tokens at a specific `_blockNumber`.\n     * @param _blockNumber The block number when the totalSupply is queried.\n     * @return The total amount of tokens at `_blockNumber`.\n     **/\n    function totalSupplyAt(uint _blockNumber) external view returns(uint256);\n\n    /**\n     * Queries the token balance of `_owner` at current block.\n     * @param _owner The address from which the balance will be retrieved.\n     * @return The current balance.\n     **/\n    function balanceOf(address _owner) external view returns (uint256);\n\n    /**\n     * Queries the token balance of `_owner` at a specific `_blockNumber`.\n     * @param _owner The address from which the balance will be retrieved.\n     * @param _blockNumber The block number when the balance is queried.\n     * @return The balance at `_blockNumber`.\n     **/\n    function balanceOfAt(address _owner, uint _blockNumber) external view returns (uint256);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/flare/util-contracts/infrastructure/userInterfaces/IPChainStakeMirrorVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\npragma abicoder v2;\n\n/**\n * Interface with structure for P-chain stake mirror verifications.\n */\ninterface IPChainStakeMirrorVerifier {\n\n    /**\n     * Structure describing the P-chain stake.\n     */\n    struct PChainStake {\n        // Hash of the transaction on the underlying chain.\n        bytes32 txId;\n        // Type of the staking/delegation transaction: '0' for 'ADD_VALIDATOR_TX' and '1' for 'ADD_DELEGATOR_TX'.\n        uint8 stakingType;\n        // Input address that triggered the staking or delegation transaction.\n        // See https://support.avax.network/en/articles/4596397-what-is-an-address for address definition for P-chain.\n        bytes20 inputAddress;\n        // NodeID to which staking or delegation is done.\n        // For definitions, see https://github.com/ava-labs/avalanchego/blob/master/ids/node_id.go.\n        bytes20 nodeId;\n        // Start time of the staking/delegation in seconds (Unix epoch).\n        uint64 startTime;\n        // End time of the staking/delegation in seconds (Unix epoch).\n        uint64 endTime;\n        // Staked or delegated amount in Gwei (nano FLR).\n        uint64 weight;\n    }\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/flare/util-contracts/infrastructure/userInterfaces/IPChainVotePower.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\n/**\n * Interface for the vote power part of the `PChainStakeMirror` contract.\n */\ninterface IPChainVotePower {\n\n    /**\n     * Event triggered when a stake is confirmed or at the time it ends.\n     * Definition: `votePowerFromTo(owner, nodeId)` is `changed` from `priorVotePower` to `newVotePower`.\n     * @param owner The account that has changed the amount of vote power it is staking.\n     * @param nodeId The node id whose received vote power has changed.\n     * @param priorVotePower The vote power originally on that node id.\n     * @param newVotePower The new vote power that triggered this event.\n     */\n    event VotePowerChanged(\n        address indexed owner,\n        bytes20 indexed nodeId,\n        uint256 priorVotePower,\n        uint256 newVotePower\n    );\n\n    /**\n     * Emitted when a vote power cache entry is created.\n     * Allows history cleaners to track vote power cache cleanup opportunities off-chain.\n     * @param nodeId The node id whose vote power has just been cached.\n     * @param blockNumber The block number at which the vote power has been cached.\n     */\n    event VotePowerCacheCreated(bytes20 nodeId, uint256 blockNumber);\n\n    /**\n    * Get the vote power of `_owner` at block `_blockNumber` using cache.\n    *   It tries to read the cached value and if not found, reads the actual value and stores it in cache.\n    *   Can only be used if _blockNumber is in the past, otherwise reverts.\n    * @param _owner The node id to get voting power.\n    * @param _blockNumber The block number at which to fetch.\n    * @return Vote power of `_owner` at `_blockNumber`.\n    */\n    function votePowerOfAtCached(bytes20 _owner, uint256 _blockNumber) external returns(uint256);\n\n    /**\n    * Get the total vote power at block `_blockNumber` using cache.\n    *   It tries to read the cached value and if not found, reads the actual value and stores it in cache.\n    *   Can only be used if `_blockNumber` is in the past, otherwise reverts.\n    * @param _blockNumber The block number at which to fetch.\n    * @return The total vote power at the block (sum of all accounts' vote powers).\n    */\n    function totalVotePowerAtCached(uint256 _blockNumber) external returns(uint256);\n\n    /**\n     * Get the current total vote power.\n     * @return The current total vote power (sum of all accounts' vote powers).\n     */\n    function totalVotePower() external view returns(uint256);\n\n    /**\n    * Get the total vote power at block `_blockNumber`\n    * @param _blockNumber The block number at which to fetch.\n    * @return The total vote power at the block  (sum of all accounts' vote powers).\n    */\n    function totalVotePowerAt(uint _blockNumber) external view returns(uint256);\n\n    /**\n     * Get the amounts and node ids being staked to by a vote power owner.\n     * @param _owner The address being queried.\n     * @return _nodeIds Array of node ids.\n     * @return _amounts Array of staked amounts, for each node id.\n     */\n    function stakesOf(address _owner)\n        external view\n        returns (\n            bytes20[] memory _nodeIds,\n            uint256[] memory _amounts\n        );\n\n    /**\n     * Get the amounts and node ids being staked to by a vote power owner,\n     * at a given block.\n     * @param _owner The address being queried.\n     * @param _blockNumber The block number being queried.\n     * @return _nodeIds Array of node ids.\n     * @return _amounts Array of staked amounts, for each node id.\n     */\n    function stakesOfAt(\n        address _owner,\n        uint256 _blockNumber\n    )\n        external view\n        returns (\n            bytes20[] memory _nodeIds,\n            uint256[] memory _amounts\n        );\n\n    /**\n     * Get the current vote power of `_nodeId`.\n     * @param _nodeId The node id to get voting power.\n     * @return Current vote power of `_nodeId`.\n     */\n    function votePowerOf(bytes20 _nodeId) external view returns(uint256);\n\n    /**\n    * Get the vote power of `_nodeId` at block `_blockNumber`\n    * @param _nodeId The node id to get voting power.\n    * @param _blockNumber The block number at which to fetch.\n    * @return Vote power of `_nodeId` at `_blockNumber`.\n    */\n    function votePowerOfAt(bytes20 _nodeId, uint256 _blockNumber) external view returns(uint256);\n\n    /**\n    * Get current staked vote power from `_owner` staked to `_nodeId`.\n    * @param _owner Address of vote power owner.\n    * @param _nodeId Node id.\n    * @return The staked vote power.\n    */\n    function votePowerFromTo(address _owner, bytes20 _nodeId) external view returns(uint256);\n\n    /**\n    * Get current staked vote power from `_owner` staked to `_nodeId` at `_blockNumber`.\n    * @param _owner Address of vote power owner.\n    * @param _nodeId Node id.\n    * @param _blockNumber The block number at which to fetch.\n    * @return The staked vote power.\n    */\n    function votePowerFromToAt(address _owner, bytes20 _nodeId, uint _blockNumber) external view returns(uint256);\n\n    /**\n     * Return vote powers for several node ids in a batch.\n     * @param _nodeIds The list of node ids to fetch vote power of.\n     * @param _blockNumber The block number at which to fetch.\n     * @return A list of vote powers.\n     */\n    function batchVotePowerOfAt(\n        bytes20[] memory _nodeIds,\n        uint256 _blockNumber\n    ) external view returns(uint256[] memory);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/flare/util-contracts/token/token/interface/IICleanable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\ninterface IICleanable {\n    /**\n     * Set the contract that is allowed to call history cleaning methods.\n     */\n    function setCleanerContract(address _cleanerContract) external;\n    \n    /**\n     * Set the cleanup block number.\n     * Historic data for the blocks before `cleanupBlockNumber` can be erased,\n     * history before that block should never be used since it can be inconsistent.\n     * In particular, cleanup block number must be before current vote power block.\n     * @param _blockNumber The new cleanup block number.\n     */\n    function setCleanupBlockNumber(uint256 _blockNumber) external;\n    \n    /**\n     * Get the current cleanup block number.\n     */\n    function cleanupBlockNumber() external view returns (uint256);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/flare/util-contracts/token/token/interface/IIGovernanceVotePower.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\nimport \"../../userInterfaces/IVPToken.sol\";\nimport \"../../../infrastructure/userInterfaces/IPChainStakeMirror.sol\";\nimport \"../../../../governance/userInterfaces/IGovernanceVotePower.sol\";\n\n/**\n * Internal interface for contracts delegating their governance vote power.\n */\ninterface IIGovernanceVotePower is IGovernanceVotePower {\n    /**\n     * Emitted when a delegate's vote power changes, as a result of a new delegation\n     * or a token transfer, for example.\n     *\n     * The event is always emitted from a `GovernanceVotePower` contract.\n     * @param delegate The account receiving the changing delegated vote power.\n     * @param previousBalance Delegated vote power before the change.\n     * @param newBalance Delegated vote power after the change.\n     */\n    event DelegateVotesChanged(\n        address indexed delegate,\n        uint256 previousBalance,\n        uint256 newBalance\n    );\n\n    /**\n     * Emitted when an account starts delegating vote power or switches its delegation\n     * to another address.\n     *\n     * The event is always emitted from a `GovernanceVotePower` contract.\n     * @param delegator Account delegating its vote power.\n     * @param fromDelegate Account receiving the delegation before the change.\n     * Can be address(0) if there was no previous delegation.\n     * @param toDelegate Account receiving the delegation after the change.\n     * Can be address(0) if `delegator` just undelegated all its vote power.\n     */\n    event DelegateChanged(\n        address indexed delegator,\n        address indexed fromDelegate,\n        address indexed toDelegate\n    );\n\n    /**\n     * Update governance vote power of all involved delegates after tokens are transferred.\n     *\n     * This function **MUST** be called after each governance token transfer for the\n     * delegates to reflect the correct balance.\n     * @param _from Source address of the transfer.\n     * @param _to Destination address of the transfer.\n     * @param _fromBalance _Ignored._\n     * @param _toBalance _Ignored._\n     * @param _amount Amount being transferred.\n     */\n    function updateAtTokenTransfer(\n        address _from,\n        address _to,\n        uint256 _fromBalance,\n        uint256 _toBalance,\n        uint256 _amount\n    ) external;\n\n    /**\n     * Set the cleanup block number.\n     * Historic data for the blocks before `cleanupBlockNumber` can be erased.\n     * History before that block should never be used since it can be inconsistent.\n     * In particular, cleanup block number must be lower than the current vote power block.\n     * @param _blockNumber The new cleanup block number.\n     */\n    function setCleanupBlockNumber(uint256 _blockNumber) external;\n\n    /**\n     * Set the contract that is allowed to call history cleaning methods.\n     * @param _cleanerContract Address of the cleanup contract.\n     * Usually this will be an instance of `CleanupBlockNumberManager`.\n     */\n    function setCleanerContract(address _cleanerContract) external;\n\n    /**\n     * Get the token that this governance vote power contract belongs to.\n     * @return The IVPToken interface owning this contract.\n     */\n    function ownerToken() external view returns (IVPToken);\n\n    /**\n     * Get the stake mirror contract that this governance vote power contract belongs to.\n     * @return The IPChainStakeMirror interface owning this contract.\n     */\n    function pChainStakeMirror() external view returns (IPChainStakeMirror);\n\n    /**\n     * Get the current cleanup block number set with `setCleanupBlockNumber()`.\n     * @return The currently set cleanup block number.\n     */\n    function getCleanupBlockNumber() external view returns(uint256);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/flare/util-contracts/token/token/interface/IIVPContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\nimport \"../../userInterfaces/IVPToken.sol\";\nimport \"../../userInterfaces/IVPContractEvents.sol\";\nimport \"./IICleanable.sol\";\n\ninterface IIVPContract is IICleanable, IVPContractEvents {\n    /**\n     * Update vote powers when tokens are transfered.\n     * Also update delegated vote powers for percentage delegation\n     * and check for enough funds for explicit delegations.\n     **/\n    function updateAtTokenTransfer(\n        address _from, \n        address _to, \n        uint256 _fromBalance,\n        uint256 _toBalance,\n        uint256 _amount\n    ) external;\n\n    /**\n     * @notice Delegate `_bips` percentage of voting power to `_to` from `_from`\n     * @param _from The address of the delegator\n     * @param _to The address of the recipient\n     * @param _balance The delegator's current balance\n     * @param _bips The percentage of voting power to be delegated expressed in basis points (1/100 of one percent).\n     *   Not cumulative - every call resets the delegation value (and value of 0 revokes delegation).\n     **/\n    function delegate(\n        address _from, \n        address _to, \n        uint256 _balance, \n        uint256 _bips\n    ) external;\n    \n    /**\n     * @notice Explicitly delegate `_amount` of voting power to `_to` from `msg.sender`.\n     * @param _from The address of the delegator\n     * @param _to The address of the recipient\n     * @param _balance The delegator's current balance\n     * @param _amount An explicit vote power amount to be delegated.\n     *   Not cumulative - every call resets the delegation value (and value of 0 undelegates `to`).\n     **/    \n    function delegateExplicit(\n        address _from, \n        address _to, \n        uint256 _balance, \n        uint _amount\n    ) external;    \n\n    /**\n     * @notice Revoke all delegation from sender to `_who` at given block. \n     *    Only affects the reads via `votePowerOfAtCached()` in the block `_blockNumber`.\n     *    Block `_blockNumber` must be in the past. \n     *    This method should be used only to prevent rogue delegate voting in the current voting block.\n     *    To stop delegating use delegate/delegateExplicit with value of 0 or undelegateAll/undelegateAllExplicit.\n     * @param _from The address of the delegator\n     * @param _who Address of the delegatee\n     * @param _balance The delegator's current balance\n     * @param _blockNumber The block number at which to revoke delegation.\n     **/\n    function revokeDelegationAt(\n        address _from, \n        address _who, \n        uint256 _balance,\n        uint _blockNumber\n    ) external;\n    \n        /**\n     * @notice Undelegate all voting power for delegates of `msg.sender`\n     *    Can only be used with percentage delegation.\n     *    Does not reset delegation mode back to NOTSET.\n     * @param _from The address of the delegator\n     **/\n    function undelegateAll(\n        address _from,\n        uint256 _balance\n    ) external;\n    \n    /**\n     * @notice Undelegate all explicit vote power by amount delegates for `msg.sender`.\n     *    Can only be used with explicit delegation.\n     *    Does not reset delegation mode back to NOTSET.\n     * @param _from The address of the delegator\n     * @param _delegateAddresses Explicit delegation does not store delegatees' addresses, \n     *   so the caller must supply them.\n     * @return The amount still delegated (in case the list of delegates was incomplete).\n     */\n    function undelegateAllExplicit(\n        address _from, \n        address[] memory _delegateAddresses\n    ) external returns (uint256);\n    \n    /**\n    * @notice Get the vote power of `_who` at block `_blockNumber`\n    *   Reads/updates cache and upholds revocations.\n    * @param _who The address to get voting power.\n    * @param _blockNumber The block number at which to fetch.\n    * @return Vote power of `_who` at `_blockNumber`.\n    */\n    function votePowerOfAtCached(address _who, uint256 _blockNumber) external returns(uint256);\n    \n    /**\n     * @notice Get the current vote power of `_who`.\n     * @param _who The address to get voting power.\n     * @return Current vote power of `_who`.\n     */\n    function votePowerOf(address _who) external view returns(uint256);\n    \n    /**\n    * @notice Get the vote power of `_who` at block `_blockNumber`\n    * @param _who The address to get voting power.\n    * @param _blockNumber The block number at which to fetch.\n    * @return Vote power of `_who` at `_blockNumber`.\n    */\n    function votePowerOfAt(address _who, uint256 _blockNumber) external view returns(uint256);\n\n    /**\n    * @notice Get the vote power of `_who` at block `_blockNumber`, ignoring revocation information (and cache).\n    * @param _who The address to get voting power.\n    * @param _blockNumber The block number at which to fetch.\n    * @return Vote power of `_who` at `_blockNumber`. Result doesn't change if vote power is revoked.\n    */\n    function votePowerOfAtIgnoringRevocation(address _who, uint256 _blockNumber) external view returns(uint256);\n\n    /**\n     * Return vote powers for several addresses in a batch.\n     * @param _owners The list of addresses to fetch vote power of.\n     * @param _blockNumber The block number at which to fetch.\n     * @return A list of vote powers.\n     */    \n    function batchVotePowerOfAt(\n        address[] memory _owners, \n        uint256 _blockNumber\n    )\n        external view returns(uint256[] memory);\n\n    /**\n    * @notice Get current delegated vote power `_from` delegator delegated `_to` delegatee.\n    * @param _from Address of delegator\n    * @param _to Address of delegatee\n    * @param _balance The delegator's current balance\n    * @return The delegated vote power.\n    */\n    function votePowerFromTo(\n        address _from, \n        address _to, \n        uint256 _balance\n    ) external view returns(uint256);\n    \n    /**\n    * @notice Get delegated the vote power `_from` delegator delegated `_to` delegatee at `_blockNumber`.\n    * @param _from Address of delegator\n    * @param _to Address of delegatee\n    * @param _balance The delegator's current balance\n    * @param _blockNumber The block number at which to fetch.\n    * @return The delegated vote power.\n    */\n    function votePowerFromToAt(\n        address _from, \n        address _to, \n        uint256 _balance,\n        uint _blockNumber\n    ) external view returns(uint256);\n\n    /**\n     * @notice Compute the current undelegated vote power of `_owner`\n     * @param _owner The address to get undelegated voting power.\n     * @param _balance Owner's current balance\n     * @return The unallocated vote power of `_owner`\n     */\n    function undelegatedVotePowerOf(\n        address _owner,\n        uint256 _balance\n    ) external view returns(uint256);\n\n    /**\n     * @notice Get the undelegated vote power of `_owner` at given block.\n     * @param _owner The address to get undelegated voting power.\n     * @param _blockNumber The block number at which to fetch.\n     * @return The undelegated vote power of `_owner` (= owner's own balance minus all delegations from owner)\n     */\n    function undelegatedVotePowerOfAt(\n        address _owner, \n        uint256 _balance,\n        uint256 _blockNumber\n    ) external view returns(uint256);\n\n    /**\n     * @notice Get the delegation mode for '_who'. This mode determines whether vote power is\n     *  allocated by percentage or by explicit value.\n     * @param _who The address to get delegation mode.\n     * @return Delegation mode (NOTSET=0, PERCENTAGE=1, AMOUNT=2))\n     */\n    function delegationModeOf(address _who) external view returns (uint256);\n    \n    /**\n    * @notice Get the vote power delegation `_delegateAddresses` \n    *  and `pcts` of an `_owner`. Returned in two separate positional arrays.\n    * @param _owner The address to get delegations.\n    * @return _delegateAddresses Positional array of delegation addresses.\n    * @return _bips Positional array of delegation percents specified in basis points (1/100 or 1 percent)\n    * @return _count The number of delegates.\n    * @return _delegationMode The mode of the delegation (NOTSET=0, PERCENTAGE=1, AMOUNT=2).\n    */\n    function delegatesOf(\n        address _owner\n    )\n        external view \n        returns (\n            address[] memory _delegateAddresses, \n            uint256[] memory _bips,\n            uint256 _count,\n            uint256 _delegationMode\n        );\n\n    /**\n    * @notice Get the vote power delegation `delegationAddresses` \n    *  and `pcts` of an `_owner`. Returned in two separate positional arrays.\n    * @param _owner The address to get delegations.\n    * @param _blockNumber The block for which we want to know the delegations.\n    * @return _delegateAddresses Positional array of delegation addresses.\n    * @return _bips Positional array of delegation percents specified in basis points (1/100 or 1 percent)\n    * @return _count The number of delegates.\n    * @return _delegationMode The mode of the delegation (NOTSET=0, PERCENTAGE=1, AMOUNT=2).\n    */\n    function delegatesOfAt(\n        address _owner,\n        uint256 _blockNumber\n    )\n        external view \n        returns (\n            address[] memory _delegateAddresses, \n            uint256[] memory _bips,\n            uint256 _count,\n            uint256 _delegationMode\n        );\n\n    /**\n     * The VPToken (or some other contract) that owns this VPContract.\n     * All state changing methods may be called only from this address.\n     * This is because original msg.sender is sent in `_from` parameter\n     * and we must be sure that it cannot be faked by directly calling VPContract.\n     * Owner token is also used in case of replacement to recover vote powers from balances.\n     */\n    function ownerToken() external view returns (IVPToken);\n    \n    /**\n     * Return true if this IIVPContract is configured to be used as a replacement for other contract.\n     * It means that vote powers are not necessarily correct at the initialization, therefore\n     * every method that reads vote power must check whether it is initialized for that address and block.\n     */\n    function isReplacement() external view returns (bool);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/flare/util-contracts/token/token/interface/IIVPToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\nimport \"../../userInterfaces/IVPToken.sol\";\nimport \"../../../../governance/userInterfaces/IGovernanceVotePower.sol\";\nimport \"./IIVPContract.sol\";\nimport \"./IIGovernanceVotePower.sol\";\nimport \"./IICleanable.sol\";\n\ninterface IIVPToken is IVPToken, IICleanable {\n    /**\n     * Set the contract that is allowed to set cleanupBlockNumber.\n     * Usually this will be an instance of CleanupBlockNumberManager.\n     */\n    function setCleanupBlockNumberManager(address _cleanupBlockNumberManager) external;\n    \n    /**\n     * Sets new governance vote power contract that allows token owners to participate in governance voting\n     * and delegate governance vote power. \n     */\n    function setGovernanceVotePower(IIGovernanceVotePower _governanceVotePower) external;\n    \n    /**\n    * @notice Get the total vote power at block `_blockNumber` using cache.\n    *   It tries to read the cached value and if not found, reads the actual value and stores it in cache.\n    *   Can only be used if `_blockNumber` is in the past, otherwise reverts.    \n    * @param _blockNumber The block number at which to fetch.\n    * @return The total vote power at the block (sum of all accounts' vote powers).\n    */\n    function totalVotePowerAtCached(uint256 _blockNumber) external returns(uint256);\n    \n    /**\n    * @notice Get the vote power of `_owner` at block `_blockNumber` using cache.\n    *   It tries to read the cached value and if not found, reads the actual value and stores it in cache.\n    *   Can only be used if _blockNumber is in the past, otherwise reverts.    \n    * @param _owner The address to get voting power.\n    * @param _blockNumber The block number at which to fetch.\n    * @return Vote power of `_owner` at `_blockNumber`.\n    */\n    function votePowerOfAtCached(address _owner, uint256 _blockNumber) external returns(uint256);\n\n    /**\n     * Return vote powers for several addresses in a batch.\n     * @param _owners The list of addresses to fetch vote power of.\n     * @param _blockNumber The block number at which to fetch.\n     * @return A list of vote powers.\n     */    \n    function batchVotePowerOfAt(\n        address[] memory _owners, \n        uint256 _blockNumber\n    ) external view returns(uint256[] memory);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/flare/util-contracts/token/userInterfaces/IVPContractEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\ninterface IVPContractEvents {\n    /**\n     * Event triggered when an account delegates or undelegates another account. \n     * Definition: `votePowerFromTo(from, to)` is `changed` from `priorVotePower` to `newVotePower`.\n     * For undelegation, `newVotePower` is 0.\n     *\n     * Note: the event is always emitted from VPToken's `writeVotePowerContract`.\n     */\n    event Delegate(address indexed from, address indexed to, uint256 priorVotePower, uint256 newVotePower);\n    \n    /**\n     * Event triggered only when account `delegator` revokes delegation to `delegatee`\n     * for a single block in the past (typically the current vote block).\n     *\n     * Note: the event is always emitted from VPToken's `writeVotePowerContract` and/or `readVotePowerContract`.\n     */\n    event Revoke(address indexed delegator, address indexed delegatee, uint256 votePower, uint256 blockNumber);\n}\n"
    },
    "@flarenetwork/flare-periphery-contracts/flare/util-contracts/token/userInterfaces/IVPToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.7.6 <0.9;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../../governance/userInterfaces/IGovernanceVotePower.sol\";\nimport \"./IVPContractEvents.sol\";\n\ninterface IVPToken is IERC20 {\n    /**\n     * @notice Delegate by percentage `_bips` of voting power to `_to` from `msg.sender`.\n     * @param _to The address of the recipient\n     * @param _bips The percentage of voting power to be delegated expressed in basis points (1/100 of one percent).\n     *   Not cumulative - every call resets the delegation value (and value of 0 undelegates `to`).\n     **/\n    function delegate(address _to, uint256 _bips) external;\n    \n    /**\n     * @notice Undelegate all percentage delegations from the sender and then delegate corresponding \n     *   `_bips` percentage of voting power from the sender to each member of `_delegatees`.\n     * @param _delegatees The addresses of the new recipients.\n     * @param _bips The percentages of voting power to be delegated expressed in basis points (1/100 of one percent).\n     *   Total of all `_bips` values must be at most 10000.\n     **/\n    function batchDelegate(address[] memory _delegatees, uint256[] memory _bips) external;\n        \n    /**\n     * @notice Explicitly delegate `_amount` of voting power to `_to` from `msg.sender`.\n     * @param _to The address of the recipient\n     * @param _amount An explicit vote power amount to be delegated.\n     *   Not cumulative - every call resets the delegation value (and value of 0 undelegates `to`).\n     **/    \n    function delegateExplicit(address _to, uint _amount) external;\n\n    /**\n    * @notice Revoke all delegation from sender to `_who` at given block. \n    *    Only affects the reads via `votePowerOfAtCached()` in the block `_blockNumber`.\n    *    Block `_blockNumber` must be in the past. \n    *    This method should be used only to prevent rogue delegate voting in the current voting block.\n    *    To stop delegating use delegate/delegateExplicit with value of 0 or undelegateAll/undelegateAllExplicit.\n    * @param _who Address of the delegatee\n    * @param _blockNumber The block number at which to revoke delegation.\n    */\n    function revokeDelegationAt(address _who, uint _blockNumber) external;\n    \n    /**\n     * @notice Undelegate all voting power for delegates of `msg.sender`\n     *    Can only be used with percentage delegation.\n     *    Does not reset delegation mode back to NOTSET.\n     **/\n    function undelegateAll() external;\n    \n    /**\n     * @notice Undelegate all explicit vote power by amount delegates for `msg.sender`.\n     *    Can only be used with explicit delegation.\n     *    Does not reset delegation mode back to NOTSET.\n     * @param _delegateAddresses Explicit delegation does not store delegatees' addresses, \n     *   so the caller must supply them.\n     * @return The amount still delegated (in case the list of delegates was incomplete).\n     */\n    function undelegateAllExplicit(address[] memory _delegateAddresses) external returns (uint256);\n\n\n    /**\n     * @dev Should be compatible with ERC20 method\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Should be compatible with ERC20 method\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Should be compatible with ERC20 method\n     */\n    function decimals() external view returns (uint8);\n    \n\n    /**\n     * @notice Total amount of tokens at a specific `_blockNumber`.\n     * @param _blockNumber The block number when the totalSupply is queried\n     * @return The total amount of tokens at `_blockNumber`\n     **/\n    function totalSupplyAt(uint _blockNumber) external view returns(uint256);\n\n    /**\n     * @dev Queries the token balance of `_owner` at a specific `_blockNumber`.\n     * @param _owner The address from which the balance will be retrieved.\n     * @param _blockNumber The block number when the balance is queried.\n     * @return The balance at `_blockNumber`.\n     **/\n    function balanceOfAt(address _owner, uint _blockNumber) external view returns (uint256);\n\n    \n    /**\n     * @notice Get the current total vote power.\n     * @return The current total vote power (sum of all accounts' vote powers).\n     */\n    function totalVotePower() external view returns(uint256);\n    \n    /**\n    * @notice Get the total vote power at block `_blockNumber`\n    * @param _blockNumber The block number at which to fetch.\n    * @return The total vote power at the block  (sum of all accounts' vote powers).\n    */\n    function totalVotePowerAt(uint _blockNumber) external view returns(uint256);\n\n    /**\n     * @notice Get the current vote power of `_owner`.\n     * @param _owner The address to get voting power.\n     * @return Current vote power of `_owner`.\n     */\n    function votePowerOf(address _owner) external view returns(uint256);\n    \n    /**\n    * @notice Get the vote power of `_owner` at block `_blockNumber`\n    * @param _owner The address to get voting power.\n    * @param _blockNumber The block number at which to fetch.\n    * @return Vote power of `_owner` at `_blockNumber`.\n    */\n    function votePowerOfAt(address _owner, uint256 _blockNumber) external view returns(uint256);\n\n    /**\n    * @notice Get the vote power of `_owner` at block `_blockNumber`, ignoring revocation information (and cache).\n    * @param _owner The address to get voting power.\n    * @param _blockNumber The block number at which to fetch.\n    * @return Vote power of `_owner` at `_blockNumber`. Result doesn't change if vote power is revoked.\n    */\n    function votePowerOfAtIgnoringRevocation(address _owner, uint256 _blockNumber) external view returns(uint256);\n\n    /**\n     * @notice Get the delegation mode for '_who'. This mode determines whether vote power is\n     *  allocated by percentage or by explicit value. Once the delegation mode is set, \n     *  it never changes, even if all delegations are removed.\n     * @param _who The address to get delegation mode.\n     * @return delegation mode: 0 = NOTSET, 1 = PERCENTAGE, 2 = AMOUNT (i.e. explicit)\n     */\n    function delegationModeOf(address _who) external view returns(uint256);\n        \n    /**\n    * @notice Get current delegated vote power `_from` delegator delegated `_to` delegatee.\n    * @param _from Address of delegator\n    * @param _to Address of delegatee\n    * @return The delegated vote power.\n    */\n    function votePowerFromTo(address _from, address _to) external view returns(uint256);\n    \n    /**\n    * @notice Get delegated the vote power `_from` delegator delegated `_to` delegatee at `_blockNumber`.\n    * @param _from Address of delegator\n    * @param _to Address of delegatee\n    * @param _blockNumber The block number at which to fetch.\n    * @return The delegated vote power.\n    */\n    function votePowerFromToAt(address _from, address _to, uint _blockNumber) external view returns(uint256);\n    \n    /**\n     * @notice Compute the current undelegated vote power of `_owner`\n     * @param _owner The address to get undelegated voting power.\n     * @return The unallocated vote power of `_owner`\n     */\n    function undelegatedVotePowerOf(address _owner) external view returns(uint256);\n    \n    /**\n     * @notice Get the undelegated vote power of `_owner` at given block.\n     * @param _owner The address to get undelegated voting power.\n     * @param _blockNumber The block number at which to fetch.\n     * @return The undelegated vote power of `_owner` (= owner's own balance minus all delegations from owner)\n     */\n    function undelegatedVotePowerOfAt(address _owner, uint256 _blockNumber) external view returns(uint256);\n    \n    /**\n    * @notice Get the vote power delegation `delegationAddresses` \n    *  and `_bips` of `_who`. Returned in two separate positional arrays.\n    * @param _who The address to get delegations.\n    * @return _delegateAddresses Positional array of delegation addresses.\n    * @return _bips Positional array of delegation percents specified in basis points (1/100 or 1 percent)\n    * @return _count The number of delegates.\n    * @return _delegationMode The mode of the delegation (NOTSET=0, PERCENTAGE=1, AMOUNT=2).\n    */\n    function delegatesOf(address _who)\n        external view \n        returns (\n            address[] memory _delegateAddresses,\n            uint256[] memory _bips,\n            uint256 _count, \n            uint256 _delegationMode\n        );\n        \n    /**\n    * @notice Get the vote power delegation `delegationAddresses` \n    *  and `pcts` of `_who`. Returned in two separate positional arrays.\n    * @param _who The address to get delegations.\n    * @param _blockNumber The block for which we want to know the delegations.\n    * @return _delegateAddresses Positional array of delegation addresses.\n    * @return _bips Positional array of delegation percents specified in basis points (1/100 or 1 percent)\n    * @return _count The number of delegates.\n    * @return _delegationMode The mode of the delegation (NOTSET=0, PERCENTAGE=1, AMOUNT=2).\n    */\n    function delegatesOfAt(address _who, uint256 _blockNumber)\n        external view \n        returns (\n            address[] memory _delegateAddresses, \n            uint256[] memory _bips, \n            uint256 _count, \n            uint256 _delegationMode\n        );\n\n    /**\n     * Returns VPContract used for readonly operations (view methods).\n     * The only non-view method that might be called on it is `revokeDelegationAt`.\n     *\n     * @notice `readVotePowerContract` is almost always equal to `writeVotePowerContract`\n     * except during upgrade from one VPContract to a new version (which should happen\n     * rarely or never and will be anounced before).\n     *\n     * @notice You shouldn't call any methods on VPContract directly, all are exposed\n     * via VPToken (and state changing methods are forbidden from direct calls). \n     * This is the reason why this method returns `IVPContractEvents` - it should only be used\n     * for listening to events (`Revoke` only).\n     */\n    function readVotePowerContract() external view returns (IVPContractEvents);\n\n    /**\n     * Returns VPContract used for state changing operations (non-view methods).\n     * The only non-view method that might be called on it is `revokeDelegationAt`.\n     *\n     * @notice `writeVotePowerContract` is almost always equal to `readVotePowerContract`\n     * except during upgrade from one VPContract to a new version (which should happen\n     * rarely or never and will be anounced before). In the case of upgrade,\n     * `writeVotePowerContract` will be replaced first to establish delegations, and\n     * after some perio (e.g. after a reward epoch ends) `readVotePowerContract` will be set equal to it.\n     *\n     * @notice You shouldn't call any methods on VPContract directly, all are exposed\n     * via VPToken (and state changing methods are forbidden from direct calls). \n     * This is the reason why this method returns `IVPContractEvents` - it should only be used\n     * for listening to events (`Delegate` and `Revoke` only).\n     */\n    function writeVotePowerContract() external view returns (IVPContractEvents);\n    \n    /**\n     * When set, allows token owners to participate in governance voting\n     * and delegate governance vote power.\n     */\n    function governanceVotePower() external view returns (IGovernanceVotePower);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@thirdweb-dev/contracts/base/ERC20Base.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @author thirdweb\n\nimport \"../external-deps/openzeppelin/token/ERC20/extensions/ERC20Permit.sol\";\n\nimport \"../extension/ContractMetadata.sol\";\nimport \"../extension/Multicall.sol\";\nimport \"../extension/Ownable.sol\";\nimport \"../extension/interface/IMintableERC20.sol\";\nimport \"../extension/interface/IBurnableERC20.sol\";\n\n/**\n *  The `ERC20Base` smart contract implements the ERC20 standard.\n *  It includes the following additions to standard ERC20 logic:\n *\n *      - Ability to mint & burn tokens via the provided `mint` & `burn` functions.\n *\n *      - Ownership of the contract, with the ability to restrict certain functions to\n *        only be called by the contract's owner.\n *\n *      - Multicall capability to perform multiple actions atomically\n *\n *      - EIP 2612 compliance: See {ERC20-permit} method, which can be used to change an account's ERC20 allowance by\n *                             presenting a message signed by the account.\n */\n\ncontract ERC20Base is ContractMetadata, Multicall, Ownable, ERC20Permit, IMintableERC20, IBurnableERC20 {\n    /*//////////////////////////////////////////////////////////////\n                            Constructor\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(address _defaultAdmin, string memory _name, string memory _symbol) ERC20Permit(_name, _symbol) {\n        _setupOwner(_defaultAdmin);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                            Minting logic\n    //////////////////////////////////////////////////////////////*/\n\n    /**\n     *  @notice          Lets an authorized address mint tokens to a recipient.\n     *  @dev             The logic in the `_canMint` function determines whether the caller is authorized to mint tokens.\n     *\n     *  @param _to       The recipient of the tokens to mint.\n     *  @param _amount   Quantity of tokens to mint.\n     */\n    function mintTo(address _to, uint256 _amount) public virtual {\n        require(_canMint(), \"Not authorized to mint.\");\n        require(_amount != 0, \"Minting zero tokens.\");\n\n        _mint(_to, _amount);\n    }\n\n    /**\n     *  @notice          Lets an owner a given amount of their tokens.\n     *  @dev             Caller should own the `_amount` of tokens.\n     *\n     *  @param _amount   The number of tokens to burn.\n     */\n    function burn(uint256 _amount) external virtual {\n        require(balanceOf(msg.sender) >= _amount, \"not enough balance\");\n        _burn(msg.sender, _amount);\n    }\n\n    /**\n     *  @notice          Lets an owner burn a given amount of an account's tokens.\n     *  @dev             `_account` should own the `_amount` of tokens.\n     *\n     *  @param _account  The account to burn tokens from.\n     *  @param _amount   The number of tokens to burn.\n     */\n    function burnFrom(address _account, uint256 _amount) external virtual override {\n        require(_canBurn(), \"Not authorized to burn.\");\n        require(balanceOf(_account) >= _amount, \"not enough balance\");\n        uint256 decreasedAllowance = allowance(_account, msg.sender) - _amount;\n        _approve(_account, msg.sender, 0);\n        _approve(_account, msg.sender, decreasedAllowance);\n        _burn(_account, _amount);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        Internal (overrideable) functions\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Returns whether contract metadata can be set in the given execution context.\n    function _canSetContractURI() internal view virtual override returns (bool) {\n        return msg.sender == owner();\n    }\n\n    /// @dev Returns whether tokens can be minted in the given execution context.\n    function _canMint() internal view virtual returns (bool) {\n        return msg.sender == owner();\n    }\n\n    /// @dev Returns whether tokens can be burned in the given execution context.\n    function _canBurn() internal view virtual returns (bool) {\n        return msg.sender == owner();\n    }\n\n    /// @dev Returns whether owner can be set in the given execution context.\n    function _canSetOwner() internal view virtual override returns (bool) {\n        return msg.sender == owner();\n    }\n\n    /// @notice Returns the sender in the given execution context.\n    function _msgSender() internal view override(Multicall, Context) returns (address) {\n        return msg.sender;\n    }\n}\n"
    },
    "@thirdweb-dev/contracts/eip/interface/IERC20.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@thirdweb-dev/contracts/eip/interface/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/**\n * @title ERC20Metadata interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ninterface IERC20Metadata {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@thirdweb-dev/contracts/eip/interface/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@thirdweb-dev/contracts/extension/ContractMetadata.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @author thirdweb\n\nimport \"./interface/IContractMetadata.sol\";\n\n/**\n *  @title   Contract Metadata\n *  @notice  Thirdweb's `ContractMetadata` is a contract extension for any base contracts. It lets you set a metadata URI\n *           for you contract.\n *           Additionally, `ContractMetadata` is necessary for NFT contracts that want royalties to get distributed on OpenSea.\n */\n\nabstract contract ContractMetadata is IContractMetadata {\n    /// @dev The sender is not authorized to perform the action\n    error ContractMetadataUnauthorized();\n\n    /// @notice Returns the contract metadata URI.\n    string public override contractURI;\n\n    /**\n     *  @notice         Lets a contract admin set the URI for contract-level metadata.\n     *  @dev            Caller should be authorized to setup contractURI, e.g. contract admin.\n     *                  See {_canSetContractURI}.\n     *                  Emits {ContractURIUpdated Event}.\n     *\n     *  @param _uri     keccak256 hash of the role. e.g. keccak256(\"TRANSFER_ROLE\")\n     */\n    function setContractURI(string memory _uri) external override {\n        if (!_canSetContractURI()) {\n            revert ContractMetadataUnauthorized();\n        }\n\n        _setupContractURI(_uri);\n    }\n\n    /// @dev Lets a contract admin set the URI for contract-level metadata.\n    function _setupContractURI(string memory _uri) internal {\n        string memory prevURI = contractURI;\n        contractURI = _uri;\n\n        emit ContractURIUpdated(prevURI, _uri);\n    }\n\n    /// @dev Returns whether contract metadata can be set in the given execution context.\n    function _canSetContractURI() internal view virtual returns (bool);\n}\n"
    },
    "@thirdweb-dev/contracts/extension/interface/IBurnableERC20.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @author thirdweb\n\ninterface IBurnableERC20 {\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) external;\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) external;\n}\n"
    },
    "@thirdweb-dev/contracts/extension/interface/IContractMetadata.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @author thirdweb\n\n/**\n *  Thirdweb's `ContractMetadata` is a contract extension for any base contracts. It lets you set a metadata URI\n *  for you contract.\n *\n *  Additionally, `ContractMetadata` is necessary for NFT contracts that want royalties to get distributed on OpenSea.\n */\n\ninterface IContractMetadata {\n    /// @dev Returns the metadata URI of the contract.\n    function contractURI() external view returns (string memory);\n\n    /**\n     *  @dev Sets contract URI for the storefront-level metadata of the contract.\n     *       Only module admin can call this function.\n     */\n    function setContractURI(string calldata _uri) external;\n\n    /// @dev Emitted when the contract URI is updated.\n    event ContractURIUpdated(string prevURI, string newURI);\n}\n"
    },
    "@thirdweb-dev/contracts/extension/interface/IMintableERC20.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @author thirdweb\n\ninterface IMintableERC20 {\n    /// @dev Emitted when tokens are minted with `mintTo`\n    event TokensMinted(address indexed mintedTo, uint256 quantityMinted);\n\n    /**\n     * @dev Creates `amount` new tokens for `to`.\n     *\n     * See {ERC20-_mint}.\n     *\n     * Requirements:\n     *\n     * - the caller must have the `MINTER_ROLE`.\n     */\n    function mintTo(address to, uint256 amount) external;\n}\n"
    },
    "@thirdweb-dev/contracts/extension/interface/IMulticall.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @author thirdweb\n\n/**\n * @dev Provides a function to batch together multiple calls in a single external call.\n *\n * _Available since v4.1._\n */\ninterface IMulticall {\n    /**\n     * @dev Receives and executes a batch of function calls on this contract.\n     */\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results);\n}\n"
    },
    "@thirdweb-dev/contracts/extension/interface/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @author thirdweb\n\n/**\n *  Thirdweb's `Ownable` is a contract extension to be used with any base contract. It exposes functions for setting and reading\n *  who the 'owner' of the inheriting smart contract is, and lets the inheriting contract perform conditional logic that uses\n *  information about who the contract's owner is.\n */\n\ninterface IOwnable {\n    /// @dev Returns the owner of the contract.\n    function owner() external view returns (address);\n\n    /// @dev Lets a module admin set a new owner for the contract. The new owner must be a module admin.\n    function setOwner(address _newOwner) external;\n\n    /// @dev Emitted when a new Owner is set.\n    event OwnerUpdated(address indexed prevOwner, address indexed newOwner);\n}\n"
    },
    "@thirdweb-dev/contracts/extension/Multicall.sol": {
      "content": "// SPDX-License-Identifier: Apache 2.0\npragma solidity ^0.8.0;\n\n/// @author thirdweb\n\nimport \"../lib/Address.sol\";\nimport \"./interface/IMulticall.sol\";\n\n/**\n * @dev Provides a function to batch together multiple calls in a single external call.\n *\n * _Available since v4.1._\n */\ncontract Multicall is IMulticall {\n    /**\n     *  @notice Receives and executes a batch of function calls on this contract.\n     *  @dev Receives and executes a batch of function calls on this contract.\n     *\n     *  @param data The bytes data that makes up the batch of function calls to execute.\n     *  @return results The bytes data that makes up the result of the batch of function calls executed.\n     */\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        address sender = _msgSender();\n        bool isForwarder = msg.sender != sender;\n        for (uint256 i = 0; i < data.length; i++) {\n            if (isForwarder) {\n                results[i] = Address.functionDelegateCall(address(this), abi.encodePacked(data[i], sender));\n            } else {\n                results[i] = Address.functionDelegateCall(address(this), data[i]);\n            }\n        }\n        return results;\n    }\n\n    /// @notice Returns the sender in the given execution context.\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n}\n"
    },
    "@thirdweb-dev/contracts/extension/Ownable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @author thirdweb\n\nimport \"./interface/IOwnable.sol\";\n\n/**\n *  @title   Ownable\n *  @notice  Thirdweb's `Ownable` is a contract extension to be used with any base contract. It exposes functions for setting and reading\n *           who the 'owner' of the inheriting smart contract is, and lets the inheriting contract perform conditional logic that uses\n *           information about who the contract's owner is.\n */\n\nabstract contract Ownable is IOwnable {\n    /// @dev The sender is not authorized to perform the action\n    error OwnableUnauthorized();\n\n    /// @dev Owner of the contract (purpose: OpenSea compatibility)\n    address private _owner;\n\n    /// @dev Reverts if caller is not the owner.\n    modifier onlyOwner() {\n        if (msg.sender != _owner) {\n            revert OwnableUnauthorized();\n        }\n        _;\n    }\n\n    /**\n     *  @notice Returns the owner of the contract.\n     */\n    function owner() public view override returns (address) {\n        return _owner;\n    }\n\n    /**\n     *  @notice Lets an authorized wallet set a new owner for the contract.\n     *  @param _newOwner The address to set as the new owner of the contract.\n     */\n    function setOwner(address _newOwner) external override {\n        if (!_canSetOwner()) {\n            revert OwnableUnauthorized();\n        }\n        _setupOwner(_newOwner);\n    }\n\n    /// @dev Lets a contract admin set a new owner for the contract. The new owner must be a contract admin.\n    function _setupOwner(address _newOwner) internal {\n        address _prevOwner = _owner;\n        _owner = _newOwner;\n\n        emit OwnerUpdated(_prevOwner, _newOwner);\n    }\n\n    /// @dev Returns whether owner can be set in the given execution context.\n    function _canSetOwner() internal view virtual returns (bool);\n}\n"
    },
    "@thirdweb-dev/contracts/external-deps/openzeppelin/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../../../eip/interface/IERC20.sol\";\nimport \"../../../../eip/interface/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@thirdweb-dev/contracts/external-deps/openzeppelin/token/ERC20/extensions/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../../../../eip/interface/IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/EIP712.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n\n    // solhint-disable-next-line var-name-mixedcase\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    // solhint-disable-next-line var-name-mixedcase\n    address private immutable _CACHED_THIS;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name_, string memory symbol_) ERC20(name_, symbol_) {\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_THIS = address(this);\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator();\n    }\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = ECDSA.toTypedDataHash(DOMAIN_SEPARATOR(), structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() public view override returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                    keccak256(bytes(name())),\n                    keccak256(\"1\"),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@thirdweb-dev/contracts/external-deps/openzeppelin/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@thirdweb-dev/contracts/external-deps/openzeppelin/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@thirdweb-dev/contracts/external-deps/openzeppelin/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../../../lib/Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@thirdweb-dev/contracts/external-deps/openzeppelin/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@thirdweb-dev/contracts/lib/Address.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.1;\n\n/// @author thirdweb, OpenZeppelin Contracts (v4.9.0)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@thirdweb-dev/contracts/lib/Strings.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @author thirdweb\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\", encoded using 2 hexadecimal digits per byte,\n    /// and the alphabets are capitalized conditionally according to\n    /// https://eips.ethereum.org/EIPS/eip-55\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\n        str = toHexString(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\n            let o := add(str, 0x22)\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\n            let t := shl(240, 136) // `0b10001000 << 240`\n            for {\n                let i := 0\n            } 1 {\n\n            } {\n                mstore(add(i, i), mul(t, byte(i, hashed)))\n                i := add(i, 1)\n                if eq(i, 20) {\n                    break\n                }\n            }\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\n            o := add(o, 0x20)\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    function toHexString(address value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            str := mload(0x40)\n\n            // Allocate the memory.\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\n            mstore(0x40, add(str, 0x80))\n\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            str := add(str, 2)\n            mstore(str, 40)\n\n            let o := add(str, 0x20)\n            mstore(add(o, 40), 0)\n\n            value := shl(96, value)\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for {\n                let i := 0\n            } 1 {\n\n            } {\n                let p := add(o, add(i, i))\n                let temp := byte(i, value)\n                mstore8(add(p, 1), mload(and(temp, 15)))\n                mstore8(p, mload(shr(4, temp)))\n                i := add(i, 1)\n                if eq(i, 20) {\n                    break\n                }\n            }\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(raw);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(raw)\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\n            mstore(str, add(length, length)) // Store the length of the output.\n\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let o := add(str, 0x20)\n            let end := add(raw, length)\n\n            for {\n\n            } iszero(eq(raw, end)) {\n\n            } {\n                raw := add(raw, 1)\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\n                o := add(o, 2)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\n        }\n    }\n}\n"
    },
    "contracts/ETF.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { IETFToken } from \"./SimpleERC20.sol\";\nimport { IERC721 } from \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {EVMTransaction} from \"@flarenetwork/flare-periphery-contracts/coston/stateConnector/interface/EVMTransaction.sol\";\nimport {FlareContractsRegistryLibrary} from \"@flarenetwork/flare-periphery-contracts/coston/util-contracts/ContractRegistryLibrary.sol\";\nimport {IFtsoRegistry} from \"@flarenetwork/flare-periphery-contracts/flare/ftso/userInterfaces/IFtsoRegistry.sol\";\n\nstruct Token {\n    address _address;\n    uint256 _quantity;\n    uint256 _chainId;\n    address _contributor;\n}\n\nstruct Vault {\n    Token[] _tokens;\n    VaultState state;\n}\n\nenum VaultState {\n    EMPTY,\n    OPEN,\n    MINTED,\n    BURNED\n}\n\n\ncontract ETF  {\n\taddress public ftsoRegistry;\n    Token[] public requiredTokens;\n    uint256 public chainId;\n    address public etfToken;\n    uint256 public  etfTokenPerVault;\n\n    mapping(uint256 => Vault) public vaults;\n\n    mapping(uint256 => address[]) public contributionsAddress;\n    mapping(uint256 => uint256[]) public contributionsAmount;\n    mapping(address => string) public symbols;\n    \n    struct EventInfo {\n    address sender;\n    uint256 quantity;\n    uint256 chainId;\n    address contributor;\n    }\n\n    struct TransactionInfo {\n        EVMTransaction.Proof originalTransaction;\n        uint256 eventNumber;\n        EventInfo[] eventInfo;\n    }\n\n\n    event Burn(\n        uint256 _vaultId,\n        address _address\n    );\n\n\n    constructor(\n        address _ftsoRegistry,\n        // array of symbols\n        string[] memory _symbols,\n        uint256 _chainId,\n        address _etfToken, \n        uint256 _etfTokenPerVault,\n        Token[] memory _requiredTokens\n        ) \n    {\n        // flareContractsRegistryLibrary = _flareContractsRegistryLibrary; // this one should check flare transactions\n       ftsoRegistry = _ftsoRegistry;\n       chainId = _chainId;\n        etfToken = _etfToken;\n        etfTokenPerVault = _etfTokenPerVault;\n        for (uint256 i = 0; i < _requiredTokens.length; i++) {\n            requiredTokens.push(_requiredTokens[i]);\n            symbols[_requiredTokens[i]._address] = _symbols[i];\n        }\n    }\n\n    function getVaultStates()\n        public\n        view\n        returns (VaultState[] memory)\n    {\n        VaultState[] memory states = new VaultState[](90);\n        for (uint256 i = 0; i < 90; i++) {\n            states[i] = vaults[i].state;\n        }\n        return states;\n    }\n\n    function getVault(uint256 _vaultId)\n        public\n        view\n        returns (Token[] memory, VaultState)\n    {\n        return (vaults[_vaultId]._tokens, vaults[_vaultId].state);\n    }\n\n\n    function checkVaultCompletion(uint256 _vaultId) public view returns (bool) {\n        for (uint256 i = 0; i < requiredTokens.length; i++) {\n            bool found = false;\n            for (uint256 j = 0; j < vaults[_vaultId]._tokens.length; j++) {\n                if (requiredTokens[i]._address == vaults[_vaultId]._tokens[j]._address) {\n                    found = true;\n                    if (requiredTokens[i]._quantity > vaults[_vaultId]._tokens[j]._quantity) {\n                        return false;\n                    }\n                    break;\n                }\n            }\n            if (!found) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function deposit(uint256 _vaultId, Token[] memory _tokens) public {\n        _deposit(_vaultId, _tokens, chainId);\n    }\n\n    function _deposit(uint256 _vaultId, Token[] memory _tokens, uint256 _chainId) private {\n        // require(vaults[_vaultId].state == VaultState.OPEN || vaults[_vaultId].state == VaultState.EMPTY,\n        //     \"Vault is not open or empty\"\n        // );\n        \n        // transfer tokens to the vault\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            if (_tokens[i]._chainId == chainId) {\n                IERC20(_tokens[i]._address).transferFrom(\n                    _tokens[i]._contributor,\n                    address(this),\n                    _tokens[i]._quantity\n                );\n            }\n            // vaults[_vaultId]._tokens.push(_tokens[i]);\n            uint256 j = 0;\n            for (j=0; j < vaults[_vaultId]._tokens.length; j++) {\n                if (vaults[_vaultId]._tokens[j]._address == _tokens[i]._address\n                    && vaults[_vaultId]._tokens[j]._chainId == _chainId\n                ) {\n                    vaults[_vaultId]._tokens[j]._quantity += _tokens[i]._quantity;\n\n                    // get the price of the token\n                    (uint256 currentSyntheticPrice, , ) = IFtsoRegistry(ftsoRegistry).getCurrentPriceWithDecimals(\n                        symbols[_tokens[i]._address]\n                    );\n                    contributionsAmount[_vaultId].push(currentSyntheticPrice * _tokens[i]._quantity);\n                    contributionsAddress[_vaultId].push(_tokens[i]._contributor);\n                    break;\n                }\n            }\n            if (j == vaults[_vaultId]._tokens.length) {\n                (uint256 currentSyntheticPrice, , ) = IFtsoRegistry(ftsoRegistry).getCurrentPriceWithDecimals(\n                        symbols[_tokens[i]._address]\n                    );\n                    contributionsAmount[_vaultId].push(currentSyntheticPrice * _tokens[i]._quantity);\n                    contributionsAddress[_vaultId].push(_tokens[i]._contributor);\n                    vaults[_vaultId]._tokens.push(_tokens[i]);\n            }\n        }\n        \n        vaults[_vaultId].state = VaultState.OPEN;\n\n        if (checkVaultCompletion(_vaultId)) {\n            vaults[_vaultId].state = VaultState.MINTED;\n            // easy scenario one owner per vault\n\n            // calculate the contribution\n            uint256 contributionslength = contributionsAddress[_vaultId].length;\n            uint256 totalContribution = 0;\n\n            for (uint256 i = 0; i < contributionslength; i++) {\n                totalContribution += contributionsAmount[_vaultId][i];\n            }\n\n            for (uint256 i = 0; i < contributionslength; i++) {\n                IETFToken(etfToken).mint(msg.sender, \n                    etfTokenPerVault * contributionsAmount[_vaultId][i] / totalContribution);\n            }\n        }\n    }\n\n    TransactionInfo[] public transactions;\n\n    function checkExternalDeposit(EVMTransaction.Proof calldata _transaction) external {\n        require(isEVMTransactionProofValid(_transaction), \"Invalid transaction proof\");\n        uint256 transactionIndex = transactions.length;\n        transactions.push();\n        transactions[transactionIndex].originalTransaction = _transaction;\n        transactions[transactionIndex].eventNumber = _transaction.data.responseBody.events.length;\n        // EventInfo[] storage eventInfo = transactions[transactionIndex].eventInfo;\n        Token[] memory tokens = new Token[](2);\n        uint256 external_chainId;\n        uint256 vaultId;\n        uint256 index=0;\n        bytes32 eventTopic = keccak256(\"Deposit(uint256,address,uint256,uint256,address)\");\n        for(uint256 i = 0; i < _transaction.data.responseBody.events.length; i++) {\n            // (address sender, uint256 value, bytes memory data) = abi.decode(_transaction.data.responseBody.events[i].data, (address, uint256, bytes));\n            if (_transaction.data.responseBody.events[i].topics[0] != eventTopic) {\n                continue;\n            }\n            (uint256 _vaultId, address _address, uint256 _quantity, uint256 _chainId, address _contributor) = abi.decode(_transaction.data.responseBody.events[i].data, (uint256, address, uint256, uint256, address));\n            tokens[index] = Token(_address, _quantity, _chainId, _contributor);\n            index++;\n            external_chainId = _chainId;\n            vaultId = _vaultId;\n        }\n        _deposit(vaultId, tokens, external_chainId);\n    }\n\n\n    function burn(uint256 _vaultId) public {\n        require(vaults[_vaultId].state == VaultState.MINTED, \"Vault was not minted!\");\n        vaults[_vaultId].state = VaultState.BURNED;\n        for (uint256 i = 0; i < vaults[_vaultId]._tokens.length; i++) {\n            if (vaults[_vaultId]._tokens[i]._chainId == chainId) {\n                IERC20(vaults[_vaultId]._tokens[i]._address).transfer(\n                    msg.sender,\n                    vaults[_vaultId]._tokens[i]._quantity\n                );\n            }\n        }\n        IETFToken(etfToken).burn(msg.sender, etfTokenPerVault);\n        emit Burn(_vaultId, msg.sender);\n    }\n    \n    function isEVMTransactionProofValid(\n        EVMTransaction.Proof calldata transaction\n    ) public view returns (bool) {\n        // Use the library to get the verifier contract and verify that this transaction was proved by state connector\n        return FlareContractsRegistryLibrary\n                .auxiliaryGetIEVMTransactionVerification()\n                .verifyEVMTransaction(transaction);\n\n                // 0x0bd4a6D3eFbB0aa8b191AE71E7dfF41c10fe8B9F\n    }\n}\n"
    },
    "contracts/SimpleERC20.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"@thirdweb-dev/contracts/base/ERC20Base.sol\";\nimport \"@thirdweb-dev/contracts/extension/Ownable.sol\";\n\ninterface IETFToken {\n\tfunction mint(address account, uint256 amount) external;\n\tfunction symbol() external view returns (string memory);\n\tfunction burn(address account, uint256 amount) external;\n}\n\ncontract SimpleERC20 is ERC20, Ownable {\n\n    \n\tconstructor(\n        string memory name,\n        string memory symbol\n    ) ERC20(name, symbol) {\n\t\t_setupOwner(msg.sender);\n\t}\n\n\t/**\n\t * @dev Function to mint new ETF tokens. Only the owner can mint.\n\t *\n\t * @param account The address that will receive the minted tokens.\n\t * @param amount The amount of tokens to mint.\n\t */\n\tfunction mint(address account, uint256 amount) external {\n\t\t_mint(account, amount);\n\t}\n\n\tfunction burn(address account, uint256 amount) external {\n\t\tsuper._burn(account, amount);\n\t}\n\n\tfunction _canSetOwner() internal view virtual override returns (bool) {\n\t\treturn msg.sender == owner();\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}